This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
babel.config.js
eslint.config.js
index.html
jest.config.cjs
package.json
postcss.config.js
public/vite.svg
README.md
src/App.css
src/App.tsx
src/assets/react.svg
src/components/__tests__/TaskCard.test.tsx
src/components/attachments/__tests__/FileUpload.test.tsx
src/components/attachments/AttachmentList.tsx
src/components/attachments/FilePreview.tsx
src/components/attachments/FileUpload.tsx
src/components/auth/Login.tsx
src/components/auth/ProtectedRoute.tsx
src/components/auth/Register.tsx
src/components/auth/RoleRoute.tsx
src/components/chat/ChatList.tsx
src/components/chat/ChatPage.tsx
src/components/chat/ChatWindow.tsx
src/components/chat/MessageInput.tsx
src/components/Header.tsx
src/components/Layout.tsx
src/components/Sidebar.tsx
src/components/TaskCard.tsx
src/components/TaskColumn.tsx
src/components/TaskModal.tsx
src/config/firebase.ts
src/hooks/useAuth.ts
src/hooks/useTaskAttachment.ts
src/index.css
src/main.tsx
src/pages/Dashboard.tsx
src/pages/Tasks.tsx
src/services/__tests__/storageService.test.ts
src/services/chatService.ts
src/services/createChannel.ts
src/services/storageService.ts
src/services/taskService.ts
src/services/userService.ts
src/setupTests.ts
src/store/index.ts
src/store/middleware/socketMiddleware.ts
src/store/slices/__tests__/authSlice.test.ts
src/store/slices/__tests__/taskSlice.test.ts
src/store/slices/authSlice.ts
src/store/slices/chatSlice.ts
src/store/slices/taskSlice.ts
src/types/__tests__/attachment.test.ts
src/types/attachment.ts
src/types/auth.ts
src/types/chat.ts
src/types/index.ts
src/types/task.ts
src/utils/fileUtils.ts
src/utils/subscriptionManager.ts
src/vite-env.d.ts
tailwind.config.js
tsconfig.app.json
tsconfig.json
tsconfig.node.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="babel.config.js">
module.exports = {
    presets: [
      '@babel/preset-env',
      '@babel/preset-react',
      '@babel/preset-typescript',
    ],
  };
</file>

<file path="eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import tseslint from 'typescript-eslint'

export default tseslint.config(
  { ignores: ['dist'] },
  {
    extends: [js.configs.recommended, ...tseslint.configs.recommended],
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
    },
    plugins: {
      'react-hooks': reactHooks,
      'react-refresh': reactRefresh,
    },
    rules: {
      ...reactHooks.configs.recommended.rules,
      'react-refresh/only-export-components': [
        'warn',
        { allowConstantExport: true },
      ],
    },
  },
)
</file>

<file path="index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>
</file>

<file path="jest.config.cjs">
module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'jsdom',
    setupFilesAfterEnv: ['<rootDir>/src/setupTests.ts'],
    moduleNameMapper: {
      '\\.(css|less|scss|sass)$': 'identity-obj-proxy',
      '^@/(.*)$': '<rootDir>/src/$1',
    },
    transform: {
      '^.+\\.(ts|tsx)$': ['ts-jest', {
        tsconfig: 'tsconfig.json'
      }]
    },
    moduleFileExtensions: ['ts', 'tsx', 'js', 'jsx', 'json', 'node'],
    testMatch: [
      '<rootDir>/src/**/__tests__/**/*.{ts,tsx}',
      '<rootDir>/src/**/*.{spec,test}.{ts,tsx}'
    ],
    globals: {
      'ts-jest': {
        tsconfig: 'tsconfig.json'
      }
    }
  };
</file>

<file path="package.json">
{
  "name": "awd-collaboration-app",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc -b && vite build",
    "lint": "eslint .",
    "preview": "vite preview",
    "test": "jest",
    "test:watch": "jest --watch"
  },
  "dependencies": {
    "@dnd-kit/core": "^6.3.1",
    "@dnd-kit/sortable": "^10.0.0",
    "@dnd-kit/utilities": "^3.2.2",
    "@firebase/auth": "^1.8.2",
    "@heroicons/react": "^2.2.0",
    "@reduxjs/toolkit": "^2.4.0",
    "@types/react-router-dom": "^5.3.3",
    "autoprefixer": "^10.4.20",
    "firebase": "^11.2.0",
    "postcss": "^8.4.49",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-dropzone": "^14.3.5",
    "react-redux": "^9.1.2",
    "react-router-dom": "^7.0.2",
    "socket.io-client": "^4.8.1",
    "tailwindcss": "^3.4.16",
    "vitest": "^3.0.4"
  },
  "devDependencies": {
    "@babel/preset-react": "^7.26.3",
    "@babel/preset-typescript": "^7.26.0",
    "@eslint/js": "^9.15.0",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react": "^16.1.0",
    "@testing-library/user-event": "^14.5.2",
    "@types/jest": "^29.5.14",
    "@types/react": "^18.3.12",
    "@types/react-dom": "^18.3.1",
    "@vitejs/plugin-react": "^4.3.4",
    "babel-jest": "^29.7.0",
    "eslint": "^9.15.0",
    "eslint-plugin-react-hooks": "^5.0.0",
    "eslint-plugin-react-refresh": "^0.4.14",
    "globals": "^15.12.0",
    "identity-obj-proxy": "^3.0.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "ts-jest": "^29.2.5",
    "ts-jest-mock-import-meta": "^1.2.1",
    "ts-node": "^10.9.2",
    "typescript": "~5.6.2",
    "typescript-eslint": "^8.15.0",
    "vite": "^6.0.1"
  }
}
</file>

<file path="postcss.config.js">
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
</file>

<file path="public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="README.md">
# React + TypeScript + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react/README.md) uses [Babel](https://babeljs.io/) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## Expanding the ESLint configuration

If you are developing a production application, we recommend updating the configuration to enable type aware lint rules:

- Configure the top-level `parserOptions` property like this:

```js
export default tseslint.config({
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})
```

- Replace `tseslint.configs.recommended` to `tseslint.configs.recommendedTypeChecked` or `tseslint.configs.strictTypeChecked`
- Optionally add `...tseslint.configs.stylisticTypeChecked`
- Install [eslint-plugin-react](https://github.com/jsx-eslint/eslint-plugin-react) and update the config:

```js
// eslint.config.js
import react from 'eslint-plugin-react'

export default tseslint.config({
  // Set the react version
  settings: { react: { version: '18.3' } },
  plugins: {
    // Add the react plugin
    react,
  },
  rules: {
    // other rules...
    // Enable its recommended rules
    ...react.configs.recommended.rules,
    ...react.configs['jsx-runtime'].rules,
  },
})
```
</file>

<file path="src/App.css">
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
</file>

<file path="src/App.tsx">
import { useEffect } from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { Provider, useSelector } from 'react-redux';
import { store } from './store';
import Layout from './components/Layout';
import Dashboard from './pages/Dashboard';
import TasksPage from './pages/Tasks';
import ChatPage from './components/chat/ChatPage';
import Login from './components/auth/Login';
import Register from './components/auth/Register';
import ProtectedRoute from './components/auth/ProtectedRoute';
import { RootState, useAppDispatch } from './store';
import { fetchTasks, unsubscribeTasks } from './store/slices/taskSlice';
import { fetchUserChats, unsubscribeAll } from './store/slices/chatSlice';
import { unregisterAllSubscriptions } from './utils/subscriptionManager';

const AppContent = () => {
  // Use the typed dispatch instead of the regular one
  const dispatch = useAppDispatch();
  const user = useSelector((state: RootState) => state.auth.user);
  const authLoading = useSelector((state: RootState) => state.auth.loading);

  // Initialize and cleanup global Firestore subscriptions
  useEffect(() => {
    if (user && !authLoading) {
      console.log('Setting up global subscriptions for user:', user.uid);
      
      // Initialize tasks subscription
      dispatch(fetchTasks());
      
      // Initialize chats subscription
      dispatch(fetchUserChats(user.uid));
    }
    
    // Cleanup subscriptions when the component unmounts
    return () => {
      console.log('Cleaning up all subscriptions');
      unsubscribeTasks();
      unsubscribeAll();
      // For extra safety, unregister all subscriptions
      unregisterAllSubscriptions();
    };
  }, [user, authLoading, dispatch]);

  return (
    <Router>
      <Routes>
        {/* Public routes */}
        <Route path="/login" element={<Login />} />
        <Route path="/register" element={<Register />} />

        {/* Protected routes */}
        <Route element={<ProtectedRoute />}>
          <Route element={<Layout />}>
            <Route path="/" element={<Dashboard />} />
            <Route path="/tasks" element={<TasksPage />} />
            <Route path="/chat" element={<ChatPage />} />
          </Route>
        </Route>

        {/* Catch all route */}
        <Route path="*" element={<Navigate to="/" replace />} />
      </Routes>
    </Router>
  );
};

function App() {
  return (
    <Provider store={store}>
      <AppContent />
    </Provider>
  );
}

export default App;
</file>

<file path="src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="src/components/__tests__/TaskCard.test.tsx">
import { render, screen, fireEvent } from '@testing-library/react';
import { DndContext } from '@dnd-kit/core';
import TaskCard from '../TaskCard';
import { Task } from '../../types/task';

describe('TaskCard', () => {
  const mockTask: Task = {
    id: '1',
    title: 'Test Task',
    description: 'Test Description',
    status: 'todo',
    priority: 'medium',
    createdBy: 'user1',
    createdAt: new Date().toISOString(),
    tags: ['test'],
    attachments: [],
  };

  // Mock functions for onEdit and onDelete
  const mockOnEdit = jest.fn();
  const mockOnDelete = jest.fn();

  const renderWithDnd = (ui: React.ReactElement) => {
    return render(
      <DndContext>
        {ui}
      </DndContext>
    );
  };

  beforeEach(() => {
    // Clear mock function calls before each test
    jest.clearAllMocks();
  });

  it('renders task details correctly', () => {
    renderWithDnd(
      <TaskCard 
        task={mockTask}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
      />
    );
    
    expect(screen.getByText('Test Task')).toBeInTheDocument();
    expect(screen.getByText('Test Description')).toBeInTheDocument();
    expect(screen.getByText('medium')).toBeInTheDocument();
    expect(screen.getByText('test')).toBeInTheDocument();
  });

  it('applies correct priority styling', () => {
    const highPriorityTask: Task = { ...mockTask, priority: 'high' };
    renderWithDnd(
      <TaskCard 
        task={highPriorityTask}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
      />
    );
    
    const priorityBadge = screen.getByText('high');
    expect(priorityBadge).toHaveClass('bg-red-100', 'text-red-800');
  });

  it('renders due date when provided', () => {
    const taskWithDueDate: Task = {
      ...mockTask,
      dueDate: '2024-12-31',
    };
    renderWithDnd(
      <TaskCard 
        task={taskWithDueDate}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
      />
    );
    
    expect(screen.getByText(/Due:/)).toBeInTheDocument();
  });

  // Add new tests for edit and delete functionality
  it('calls onEdit when edit button is clicked', () => {
    renderWithDnd(
      <TaskCard 
        task={mockTask}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
      />
    );
    
    // Find and click the edit button
    const editButton = screen.getByRole('button', { name: /edit/i });
    fireEvent.click(editButton);
    
    expect(mockOnEdit).toHaveBeenCalledWith(mockTask);
  });

  it('calls onDelete when delete button is clicked', () => {
    renderWithDnd(
      <TaskCard 
        task={mockTask}
        onEdit={mockOnEdit}
        onDelete={mockOnDelete}
      />
    );
    
    // Find and click the delete button
    const deleteButton = screen.getByRole('button', { name: /delete/i });
    fireEvent.click(deleteButton);
    
    expect(mockOnDelete).toHaveBeenCalledWith(mockTask.id);
  });
});
</file>

<file path="src/components/attachments/__tests__/FileUpload.test.tsx">
import { render, fireEvent, screen } from '@testing-library/react';
import FileUpload from '../FileUpload';

jest.mock('../../../hooks/useTaskAttachment', () => ({
  useTaskAttachment: () => ({
    uploadFile: jest.fn(),
    uploadProgress: {},
  }),
}));

describe('FileUpload', () => {
  it('renders upload button', () => {
    render(<FileUpload taskId="test-task" />);
    expect(screen.getByText('Attach File')).toBeInTheDocument();
  });

});
</file>

<file path="src/components/attachments/AttachmentList.tsx">
import { TaskAttachment } from '../../types/attachment';
import FilePreview from './FilePreview';
import { useTaskAttachment } from '../../hooks/useTaskAttachment';

interface AttachmentListProps {
  taskId: string;
  attachments: TaskAttachment[];
}

const AttachmentList = ({ taskId, attachments }: AttachmentListProps) => {
  const { deleteFile } = useTaskAttachment(taskId);

  const handleDelete = async (attachment: TaskAttachment) => {
    try {
      await deleteFile(attachment.id, attachment.fileName);
    } catch (error) {
      console.error('Failed to delete attachment:', error);
    }
  };

  if (!attachments?.length) {
    return null;
  }

  return (
    <div className="mt-4 space-y-4">
      <h4 className="text-sm font-medium text-gray-900">Attachments</h4>
      <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 lg:grid-cols-3">
        {attachments.map((attachment) => (
          <FilePreview
            key={attachment.id}
            attachment={attachment}
            onDelete={handleDelete}
          />
        ))}
      </div>
    </div>
  );
};

export default AttachmentList;
</file>

<file path="src/components/attachments/FilePreview.tsx">
import { ArrowDownTrayIcon, TrashIcon } from '@heroicons/react/24/outline';
import { TaskAttachment } from '../../types/attachment';
import { formatFileSize, getFileTypeInfo } from '../../utils/fileUtils';

interface FilePreviewProps {
  attachment: TaskAttachment;
  onDelete?: (attachment: TaskAttachment) => void;
}

const FilePreview = ({ attachment, onDelete }: FilePreviewProps) => {
  const { icon: Icon, label: fileTypeLabel, color } = getFileTypeInfo(attachment.fileType);
  const isImage = attachment.fileType.startsWith('image/');
  const uploadDate = new Date(attachment.uploadedAt).toLocaleDateString();

  return (
    <div className="group relative rounded-lg border border-gray-200 bg-white shadow-sm hover:shadow-md transition-shadow">
      {isImage && attachment.downloadUrl ? (
        <div className="aspect-video w-full rounded-t-lg overflow-hidden bg-gray-100">
          <img
            src={attachment.downloadUrl}
            alt={attachment.fileName}
            className="w-full h-full object-cover"
          />
        </div>
      ) : (
        <div className="aspect-video w-full rounded-t-lg flex items-center justify-center bg-gray-50">
          <Icon className={`h-16 w-16 ${color}`} />
        </div>
      )}
      
      <div className="p-4">
        <div className="mb-2 flex items-start justify-between">
          <div className="truncate">
            <h4 className="text-sm font-medium text-gray-900 truncate" title={attachment.fileName}>
              {attachment.fileName}
            </h4>
            <p className="text-xs text-gray-500">
              {fileTypeLabel} • {formatFileSize(attachment.fileSize)}
            </p>
          </div>
        </div>

        <div className="text-xs text-gray-500 mb-3">
          Uploaded {uploadDate}
        </div>

        <div className="flex gap-2">
          <a
            href={attachment.downloadUrl}
            download={attachment.fileName}
            className="flex-1 inline-flex items-center justify-center px-3 py-1.5 text-sm font-medium rounded-md text-gray-700 bg-gray-50 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
          >
            <ArrowDownTrayIcon className="h-4 w-4 mr-1" />
            Download
          </a>
          {onDelete && (
            <button
              onClick={() => onDelete(attachment)}
              className="inline-flex items-center justify-center px-3 py-1.5 text-sm font-medium rounded-md text-red-700 bg-red-50 hover:bg-red-100 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500"
              title="Delete attachment"
            >
              <TrashIcon className="h-4 w-4" />
            </button>
          )}
        </div>
      </div>
    </div>
  );
};

export default FilePreview;
</file>

<file path="src/components/attachments/FileUpload.tsx">
import { ChangeEvent, useRef } from 'react';
import { PaperClipIcon } from '@heroicons/react/24/outline';
import { useTaskAttachment } from '../../hooks/useTaskAttachment';
import { validateFile } from '../../utils/fileUtils';

interface FileUploadProps {
  taskId: string;
  onUploadComplete?: () => void;
  onError?: (error: string) => void;
}

const FileUpload = ({ taskId, onUploadComplete, onError }: FileUploadProps) => {
  const fileInputRef = useRef<HTMLInputElement>(null);
  const { uploadFile, uploadProgress } = useTaskAttachment(taskId);

  const handleFileChange = async (e: ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files?.length) return;

    const file = files[0];
    const validation = validateFile(file);
    
    if (!validation.isValid) {
      onError?.(validation.error || 'Invalid file');
      return;
    }

    try {
      await uploadFile(file);
      onUploadComplete?.();
    } catch (error) {
      onError?.(error instanceof Error ? error.message : 'Upload failed');
    }

    // Reset input
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  return (
    <div>
      <input
        ref={fileInputRef}
        type="file"
        className="hidden"
        onChange={handleFileChange}
      />
      <button
        type="button"
        onClick={() => fileInputRef.current?.click()}
        className="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
      >
        <PaperClipIcon className="-ml-0.5 mr-2 h-4 w-4" aria-hidden="true" />
        Attach File
      </button>
      {Object.entries(uploadProgress).map(([fileName, progress]) => (
        progress.progress < 100 && (
          <div key={fileName} className="mt-2">
            <div className="text-sm text-gray-600">{fileName}</div>
            <div className="w-full bg-gray-200 rounded-full h-2.5">
              <div
                className="bg-primary-600 h-2.5 rounded-full"
                style={{ width: `${progress.progress}%` }}
              />
            </div>
          </div>
        )
      ))}
    </div>
  );
};

export default FileUpload;
</file>

<file path="src/components/auth/Login.tsx">
import { useState, FormEvent } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';

const Login = () => {
  const navigate = useNavigate();
  const { signIn } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    try {
      await signIn(email, password);
      navigate('/');
    } catch (err) {
      setError('Failed to sign in. Please check your credentials.');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Sign in to your account
          </h2>
        </div>
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <div className="text-sm text-red-700">{error}</div>
            </div>
          )}
          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <label htmlFor="email-address" className="sr-only">
                Email address
              </label>
              <input
                id="email-address"
                name="email"
                type="email"
                required
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Email address"
              />
            </div>
            <div>
              <label htmlFor="password" className="sr-only">
                Password
              </label>
              <input
                id="password"
                name="password"
                type="password"
                required
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Password"
              />
            </div>
          </div>

          <div>
            <button
              type="submit"
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
            >
              Sign in
            </button>
          </div>

          <div className="text-sm text-center">
            <Link
              to="/register"
              className="font-medium text-primary-600 hover:text-primary-500"
            >
              Don't have an account? Sign up
            </Link>
          </div>
        </form>
      </div>
    </div>
  );
};

export default Login;
</file>

<file path="src/components/auth/ProtectedRoute.tsx">
import { useEffect } from 'react';
import { useNavigate, useLocation, Outlet } from 'react-router-dom';
import { useSelector } from 'react-redux';
import { RootState } from '../../store';
import { useAuth } from '../../hooks/useAuth';

const ProtectedRoute = () => {
  const navigate = useNavigate();
  const location = useLocation();
  const { loading } = useAuth();
  const user = useSelector((state: RootState) => state.auth.user);

  useEffect(() => {
    if (!loading && !user) {
      navigate('/login', { state: { from: location }, replace: true });
    }
  }, [user, loading, navigate, location]);

  if (loading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-primary-600"></div>
      </div>
    );
  }

  return user ? <Outlet /> : null;
};

export default ProtectedRoute;
</file>

<file path="src/components/auth/Register.tsx">
import { useState, FormEvent } from 'react';
import { Link, useNavigate } from 'react-router-dom';
import { useAuth } from '../../hooks/useAuth';

const Register = () => {
  const navigate = useNavigate();
  const { signUp } = useAuth();
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    
    if (password !== confirmPassword) {
      setError('Passwords do not match');
      return;
    }

    try {
      await signUp(email, password);
      navigate('/');
    } catch (err) {
      setError('Failed to create account.');
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 py-12 px-4 sm:px-6 lg:px-8">
      <div className="max-w-md w-full space-y-8">
        <div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
            Create your account
          </h2>
        </div>
        <form className="mt-8 space-y-6" onSubmit={handleSubmit}>
          {error && (
            <div className="rounded-md bg-red-50 p-4">
              <div className="text-sm text-red-700">{error}</div>
            </div>
          )}
          <div className="rounded-md shadow-sm -space-y-px">
            <div>
              <label htmlFor="email-address" className="sr-only">
                Email address
              </label>
              <input
                id="email-address"
                name="email"
                type="email"
                required
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-t-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Email address"
              />
            </div>
            <div>
              <label htmlFor="password" className="sr-only">
                Password
              </label>
              <input
                id="password"
                name="password"
                type="password"
                required
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Password"
              />
            </div>
            <div>
              <label htmlFor="confirm-password" className="sr-only">
                Confirm Password
              </label>
              <input
                id="confirm-password"
                name="confirm-password"
                type="password"
                required
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                className="appearance-none rounded-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-b-md focus:outline-none focus:ring-primary-500 focus:border-primary-500 focus:z-10 sm:text-sm"
                placeholder="Confirm Password"
              />
            </div>
          </div>

          <div>
            <button
              type="submit"
              className="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
            >
              Register
            </button>
          </div>

          <div className="text-sm text-center">
            <Link
              to="/login"
              className="font-medium text-primary-600 hover:text-primary-500"
            >
              Already have an account? Sign in
            </Link>
          </div>
        </form>
      </div>
    </div>
  );
};

export default Register;
</file>

<file path="src/components/auth/RoleRoute.tsx">
import { useSelector } from 'react-redux';
import { Navigate, Outlet } from 'react-router-dom';
import { RootState } from '../../store';
import { UserRole } from '../../types/auth';

interface RoleRouteProps {
  allowedRoles: (keyof UserRole)[];
}

const RoleRoute = ({ allowedRoles }: RoleRouteProps) => {
  const user = useSelector((state: RootState) => state.auth.user);

  if (!user) {
    return <Navigate to="/login" replace />;
  }

  const hasRequiredRole = allowedRoles.some(role => user.roles[role]);

  if (!hasRequiredRole) {
    return <Navigate to="/" replace />;
  }

  return <Outlet />;
};

export default RoleRoute;
</file>

<file path="src/components/chat/ChatList.tsx">
import { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import { RootState, useAppDispatch } from '../../store';
import { setCurrentChat, createChannel, fetchUserChats } from '../../store/slices/chatSlice';
import { HashtagIcon, UserCircleIcon, PlusIcon, ArrowPathIcon } from '@heroicons/react/24/outline';

const ChatList = () => {
  // Use the typed dispatch
  const dispatch = useAppDispatch();
  const { activeChats, currentChatId, loading, error } = useSelector((state: RootState) => state.chat);
  const user = useSelector((state: RootState) => state.auth.user);
  const [isCreatingChannel, setIsCreatingChannel] = useState(false);
  const [newChannelName, setNewChannelName] = useState('');
  const [newChannelDescription, setNewChannelDescription] = useState('');
  const [creationError, setCreationError] = useState<string | null>(null);
  const [isCreating, setIsCreating] = useState(false);

  // Debug logging
  useEffect(() => {
    console.log('ChatList renders with chats:', activeChats);
  }, [activeChats]);

  // Separate channels and direct messages
  const channels = activeChats.filter(chat => chat.type === 'channel');
  const directMessages = activeChats.filter(chat => chat.type === 'direct');

  const handleCreateChannel = async () => {
    if (!newChannelName.trim() || !user) {
      setCreationError('Channel name is required');
      return;
    }
    
    try {
      setIsCreating(true);
      setCreationError(null);
      console.log('Creating channel with data:', {
        name: newChannelName.trim(),
        description: newChannelDescription.trim(),
        creatorId: user.uid,
      });
      
      const result = await dispatch(createChannel({
        name: newChannelName.trim(),
        description: newChannelDescription.trim(),
        creatorId: user.uid,
      })).unwrap();
      
      console.log('Channel created successfully:', result);
      
      // Set the new channel as current
      dispatch(setCurrentChat(result.id));
      
      // Reset form
      setNewChannelName('');
      setNewChannelDescription('');
      setIsCreatingChannel(false);
    } catch (error) {
      console.error('Failed to create channel:', error);
      setCreationError('Failed to create channel: ' + (error instanceof Error ? error.message : String(error)));
    } finally {
      setIsCreating(false);
    }
  };

  // Function to refresh chats
  const handleRefreshChats = () => {
    if (user) {
      console.log('Manually refreshing chats');
      dispatch(fetchUserChats(user.uid));
    }
  };

  return (
    <div className="h-full flex flex-col">
      <div className="p-4 border-b border-gray-200 flex justify-between items-center">
        <h2 className="text-lg font-semibold text-gray-800">Chat</h2>
        <div className="flex space-x-2">
          <button
            onClick={handleRefreshChats}
            className="p-1 text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded"
            title="Refresh chats"
          >
            <ArrowPathIcon className="h-5 w-5" />
          </button>
          <button
            onClick={() => setIsCreatingChannel(!isCreatingChannel)}
            className="p-1 text-gray-500 hover:text-gray-700 hover:bg-gray-100 rounded"
            title="Create new channel"
          >
            <PlusIcon className="h-5 w-5" />
          </button>
        </div>
      </div>
      
      {/* Error display */}
      {error && (
        <div className="p-3 bg-red-50 border-l-4 border-red-500 text-red-700 text-sm">
          <p className="font-bold">Error</p>
          <p>{error}</p>
        </div>
      )}
      
      {/* Channel creation form */}
      {isCreatingChannel && (
        <div className="p-4 border-b border-gray-200 bg-gray-50">
          <h3 className="text-sm font-medium text-gray-700 mb-2">Create New Channel</h3>
          {creationError && (
            <div className="mb-2 p-2 bg-red-50 border-l-4 border-red-500 text-red-700 text-xs">
              {creationError}
            </div>
          )}
          <div className="space-y-2">
            <input
              type="text"
              value={newChannelName}
              onChange={(e) => setNewChannelName(e.target.value)}
              placeholder="Channel name"
              className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm"
              disabled={isCreating}
            />
            <input
              type="text"
              value={newChannelDescription}
              onChange={(e) => setNewChannelDescription(e.target.value)}
              placeholder="Description (optional)"
              className="w-full px-3 py-2 border border-gray-300 rounded-md text-sm"
              disabled={isCreating}
            />
            <div className="flex justify-end space-x-2">
              <button
                onClick={() => {
                  setIsCreatingChannel(false);
                  setCreationError(null);
                }}
                className="px-3 py-1 text-sm text-gray-700 hover:bg-gray-100 rounded"
                disabled={isCreating}
              >
                Cancel
              </button>
              <button
                onClick={handleCreateChannel}
                disabled={!newChannelName.trim() || isCreating}
                className="px-3 py-1 text-sm bg-primary-600 text-white rounded hover:bg-primary-700 disabled:opacity-50 flex items-center"
              >
                {isCreating ? (
                  <>
                    <ArrowPathIcon className="h-4 w-4 mr-1 animate-spin" />
                    Creating...
                  </>
                ) : 'Create'}
              </button>
            </div>
          </div>
        </div>
      )}
      
      <div className="flex-1 overflow-y-auto">
        {/* Channels */}
        <div className="p-4">
          <h3 className="text-xs font-semibold text-gray-500 uppercase tracking-wider">
            Channels ({channels.length})
          </h3>
          <div className="mt-2 space-y-1">
            {loading && channels.length === 0 ? (
              <div className="text-center py-2 text-gray-500 text-sm">Loading...</div>
            ) : channels.length === 0 ? (
              <div className="text-center py-2 text-gray-500 text-sm">No channels yet</div>
            ) : (
              channels.map(chat => (
                <button
                  key={chat.id}
                  onClick={() => dispatch(setCurrentChat(chat.id))}
                  className={`w-full flex items-center px-2 py-1.5 text-sm rounded-md ${
                    currentChatId === chat.id
                      ? 'bg-gray-100 text-gray-900'
                      : 'text-gray-600 hover:bg-gray-50'
                  }`}
                >
                  <HashtagIcon className="mr-2 h-4 w-4" />
                  <span className="truncate">{chat.name}</span>
                </button>
              ))
            )}
          </div>
        </div>

        {/* Direct Messages */}
        <div className="p-4">
          <h3 className="text-xs font-semibold text-gray-500 uppercase tracking-wider">
            Direct Messages ({directMessages.length})
          </h3>
          <div className="mt-2 space-y-1">
            {loading && directMessages.length === 0 ? (
              <div className="text-center py-2 text-gray-500 text-sm">Loading...</div>
            ) : directMessages.length === 0 ? (
              <div className="text-center py-2 text-gray-500 text-sm">No direct messages yet</div>
            ) : (
              directMessages.map(chat => (
                <button
                  key={chat.id}
                  onClick={() => dispatch(setCurrentChat(chat.id))}
                  className={`w-full flex items-center px-2 py-1.5 text-sm rounded-md ${
                    currentChatId === chat.id
                      ? 'bg-gray-100 text-gray-900'
                      : 'text-gray-600 hover:bg-gray-50'
                  }`}
                >
                  <UserCircleIcon className="mr-2 h-4 w-4" />
                  <span className="truncate">{chat.name}</span>
                </button>
              ))
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default ChatList;
</file>

<file path="src/components/chat/ChatPage.tsx">
import { useEffect } from 'react';
import { useSelector } from 'react-redux';
import { RootState, useAppDispatch } from '../../store';
import { fetchUserChats, setCurrentChat } from '../../store/slices/chatSlice';
import ChatList from './ChatList';
import ChatWindow from './ChatWindow';

const ChatPage = () => {
  // Use typed dispatch
  const dispatch = useAppDispatch();
  const { activeChats, currentChatId, loading, error } = useSelector(
    (state: RootState) => state.chat
  );
  const user = useSelector((state: RootState) => state.auth.user);

  // Manually fetch chats when needed
  useEffect(() => {
    if (user && activeChats.length === 0) {
      console.log('Explicitly fetching chats for user:', user.uid);
      dispatch(fetchUserChats(user.uid));
    }
  }, [dispatch, user, activeChats.length]);

  // Set first chat as active if none selected
  useEffect(() => {
    if (!currentChatId && activeChats.length > 0) {
      console.log('Setting first chat as active:', activeChats[0].id);
      dispatch(setCurrentChat(activeChats[0].id));
    }
  }, [activeChats, currentChatId, dispatch]);

  // Debug logs
  useEffect(() => {
    console.log('Chat state update:', {
      activeChats, 
      currentChatId, 
      loading,
      error,
      chatCount: activeChats.length
    });
  }, [activeChats, currentChatId, loading, error]);

  // Check for errors
  if (error) {
    return (
      <div className="h-full flex items-center justify-center text-red-600">
        <div className="text-center p-4 bg-red-100 rounded-lg">
          <p className="font-bold">Error loading chats:</p>
          <p>{error}</p>
          <button 
            className="mt-4 px-4 py-2 bg-red-600 text-white rounded"
            onClick={() => dispatch(fetchUserChats(user?.uid || ''))}
          >
            Retry
          </button>
        </div>
      </div>
    );
  }

  if (loading && activeChats.length === 0) {
    return (
      <div className="h-full flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin inline-block rounded-full h-12 w-12 border-b-2 border-primary-600"></div>
          <p className="mt-4 text-gray-600">Loading chats...</p>
        </div>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      <div className="flex-1 flex min-h-0">
        <div className="w-64 border-r border-gray-200 bg-white">
          <ChatList />
        </div>
        <div className="flex-1">
          <ChatWindow />
        </div>
      </div>
    </div>
  );
};

export default ChatPage;
</file>

<file path="src/components/chat/ChatWindow.tsx">
import { useEffect, useRef } from 'react';
import { useSelector } from 'react-redux';
import { RootState, useAppDispatch } from '../../store';
import { Message } from '../../types/chat';
import MessageInput from './MessageInput';
import { fetchChatMessages } from '../../store/slices/chatSlice';

const ChatMessage = ({ message, currentUserId }: { message: Message; currentUserId: string }) => {
  const isOwnMessage = message.senderId === currentUserId;

  return (
    <div
      className={`flex ${isOwnMessage ? 'justify-end' : 'justify-start'} mb-4`}
    >
      <div
        className={`max-w-[70%] rounded-lg px-4 py-2 ${
          isOwnMessage
            ? 'bg-primary-600 text-white'
            : 'bg-gray-100 text-gray-900'
        }`}
      >
        <div className="text-sm">{message.content}</div>
        <div className={`text-xs mt-1 ${isOwnMessage ? 'text-primary-100' : 'text-gray-500'}`}>
          {new Date(message.timestamp).toLocaleTimeString()}
        </div>
      </div>
    </div>
  );
};

const ChatWindow = () => {
  // Use typed dispatch
  const dispatch = useAppDispatch();
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const { currentChatId, messages, activeChats, loading } = useSelector(
    (state: RootState) => state.chat
  );
  const user = useSelector((state: RootState) => state.auth.user);
  
  const currentChat = activeChats.find(chat => chat.id === currentChatId);
  const currentMessages = currentChatId ? (messages[currentChatId] || []) : [];

  // Fetch messages when chat changes
  useEffect(() => {
    if (currentChatId) {
      dispatch(fetchChatMessages(currentChatId));
    }
  }, [currentChatId, dispatch]);
  
  // Scroll to bottom when messages change
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [currentMessages]);

  if (!currentChatId || !currentChat) {
    return (
      <div className="h-full flex items-center justify-center text-gray-500">
        Select a chat to start messaging
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      {/* Chat Header */}
      <div className="flex-shrink-0 p-4 border-b border-gray-200">
        <h2 className="text-lg font-semibold text-gray-800">
          {currentChat.type === 'channel' ? '#' : ''}{currentChat.name}
        </h2>
        {currentChat.description && (
          <p className="text-sm text-gray-500">{currentChat.description}</p>
        )}
      </div>

      {/* Messages */}
      <div className="flex-1 overflow-y-auto p-4 space-y-4">
        {loading && currentMessages.length === 0 ? (
          <div className="flex justify-center items-center h-24">
            <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary-600"></div>
          </div>
        ) : currentMessages.length === 0 ? (
          <div className="text-center text-gray-500 py-8">
            No messages yet. Be the first to say something!
          </div>
        ) : (
          currentMessages.map((message) => (
            <ChatMessage 
              key={message.id} 
              message={message} 
              currentUserId={user?.uid || ''} 
            />
          ))
        )}
        <div ref={messagesEndRef} />
      </div>

      {/* Message Input */}
      <MessageInput chatId={currentChatId} />
    </div>
  );
};

export default ChatWindow;
</file>

<file path="src/components/chat/MessageInput.tsx">
import { useState, FormEvent } from 'react';
import { useSelector } from 'react-redux';
import { PaperClipIcon, PaperAirplaneIcon } from '@heroicons/react/24/outline';
import { sendMessage } from '../../store/slices/chatSlice';
import { RootState, useAppDispatch } from '../../store';

interface MessageInputProps {
  chatId: string;
}

const MessageInput = ({ chatId }: MessageInputProps) => {
  // Use typed dispatch
  const dispatch = useAppDispatch();
  const [message, setMessage] = useState('');
  const [isSubmitting, setIsSubmitting] = useState(false);
  const user = useSelector((state: RootState) => state.auth.user);

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    
    if (!message.trim() || !user) return;
    
    try {
      setIsSubmitting(true);
      await dispatch(sendMessage({ 
        chatId, 
        content: message.trim(), 
        senderId: user.uid 
      })).unwrap();
      setMessage('');
    } catch (error) {
      console.error('Failed to send message:', error);
    } finally {
      setIsSubmitting(false);
    }
  };

  return (
    <form onSubmit={handleSubmit} className="p-4 border-t border-gray-200">
      <div className="flex items-center space-x-2">
        <button
          type="button"
          className="p-2 text-gray-400 hover:text-gray-500 rounded-full hover:bg-gray-100"
          title="Attach file"
        >
          <PaperClipIcon className="h-5 w-5" />
        </button>
        <div className="flex-1">
          <input
            type="text"
            value={message}
            onChange={(e) => setMessage(e.target.value)}
            placeholder="Type a message..."
            className="w-full px-4 py-2 border border-gray-300 rounded-full focus:outline-none focus:ring-2 focus:ring-primary-500 focus:border-transparent"
            disabled={isSubmitting}
          />
        </div>
        <button
          type="submit"
          disabled={!message.trim() || isSubmitting}
          className="p-2 text-primary-600 hover:text-primary-700 rounded-full hover:bg-gray-100 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          {isSubmitting ? (
            <div className="h-5 w-5 animate-spin rounded-full border-2 border-primary-600 border-t-transparent" />
          ) : (
            <PaperAirplaneIcon className="h-5 w-5" />
          )}
        </button>
      </div>
    </form>
  );
};

export default MessageInput;
</file>

<file path="src/components/Header.tsx">
import { useSelector } from 'react-redux';
import { BellIcon, UserCircleIcon } from '@heroicons/react/24/outline';
import { useAuth } from '../hooks/useAuth';
import { RootState } from '../store';
import { useState, useRef, useEffect } from 'react';

const Header = () => {
  const { signOut } = useAuth();
  const user = useSelector((state: RootState) => state.auth.user);
  const [isProfileOpen, setIsProfileOpen] = useState(false);
  const dropdownRef = useRef<HTMLDivElement>(null);

  // Close dropdown when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target as Node)) {
        setIsProfileOpen(false);
      }
    };

    document.addEventListener('mousedown', handleClickOutside);
    return () => document.removeEventListener('mousedown', handleClickOutside);
  }, []);

  const handleLogout = async () => {
    try {
      await signOut();
    } catch (error) {
      console.error('Failed to logout:', error);
    }
  };

  return (
    <div className="relative z-10 flex-shrink-0 flex h-16 bg-white border-b border-gray-200">
      <div className="flex-1 px-4 flex justify-between">
        <div className="flex-1 flex">
          {/* Add search functionality here if needed */}
        </div>
        <div className="ml-4 flex items-center">
          <button
            type="button"
            className="bg-white p-1 rounded-full text-gray-400 hover:text-gray-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
          >
            <span className="sr-only">View notifications</span>
            <BellIcon className="h-6 w-6" aria-hidden="true" />
          </button>

          <div className="ml-3 relative" ref={dropdownRef}>
            <button
              className="max-w-xs bg-white flex items-center text-sm rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
              onClick={() => setIsProfileOpen(!isProfileOpen)}
            >
              <span className="sr-only">Open user menu</span>
              {user?.photoURL ? (
                <img
                  className="h-8 w-8 rounded-full"
                  src={user.photoURL}
                  alt=""
                />
              ) : (
                <div className="h-8 w-8 rounded-full bg-gray-200 flex items-center justify-center">
                  <UserCircleIcon className="h-6 w-6 text-gray-400" />
                </div>
              )}
            </button>

            {isProfileOpen && (
              <div className="origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white ring-1 ring-black ring-opacity-5 focus:outline-none">
                <div className="px-4 py-2 text-sm text-gray-700 border-b">
                  {user?.email}
                </div>
                <button
                  onClick={() => {/* Add profile navigation */}}
                  className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                >
                  Your Profile
                </button>
                <button
                  onClick={() => {/* Add settings navigation */}}
                  className="block w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"
                >
                  Settings
                </button>
                <button
                  onClick={handleLogout}
                  className="block w-full text-left px-4 py-2 text-sm text-red-700 hover:bg-gray-100"
                >
                  Sign out
                </button>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default Header;
</file>

<file path="src/components/Layout.tsx">
import { Outlet } from 'react-router-dom';
import Sidebar from './Sidebar';
import Header from './Header';

const Layout = () => {
  return (
    <div className="h-screen flex overflow-hidden bg-gray-100">
      <Sidebar />
      <div className="flex flex-col w-0 flex-1 overflow-hidden">
        <Header />
        <main className="flex-1 relative overflow-y-auto focus:outline-none">
          <div className="py-6">
            <div className="max-w-7xl mx-auto px-4 sm:px-6 md:px-8">
              <Outlet />
            </div>
          </div>
        </main>
      </div>
    </div>
  );
};

export default Layout;
</file>

<file path="src/components/Sidebar.tsx">
import { NavLink } from 'react-router-dom';
import { HomeIcon, ClipboardDocumentListIcon, ChatBubbleLeftRightIcon, CalendarIcon } from '@heroicons/react/24/outline';

const navigation = [
  { name: 'Dashboard', path: '/', icon: HomeIcon },
  { name: 'Tasks', path: '/tasks', icon: ClipboardDocumentListIcon },
  { name: 'Chat', path: '/chat', icon: ChatBubbleLeftRightIcon },
  { name: 'Calendar', path: '/calendar', icon: CalendarIcon },
];

const Sidebar = () => {
  return (
    <div className="flex flex-shrink-0">
      <div className="flex flex-col w-64">
        <div className="flex flex-col flex-grow pt-5 pb-4 overflow-y-auto bg-white border-r border-gray-200">
          <div className="flex items-center flex-shrink-0 px-4">
            <h1 className="text-xl font-semibold text-gray-800">Collaboration App</h1>
          </div>
          <div className="mt-5 flex-grow flex flex-col">
            <nav className="flex-1 px-2 space-y-1">
              {navigation.map((item) => (
                <NavLink
                  key={item.name}
                  to={item.path}
                  className={({ isActive }) =>
                    `group flex items-center px-2 py-2 text-sm font-medium rounded-md ${
                      isActive
                        ? 'bg-gray-100 text-gray-900'
                        : 'text-gray-600 hover:bg-gray-50 hover:text-gray-900'
                    }`
                  }
                >
                  {item.icon && (
                    <item.icon
                      className="mr-3 flex-shrink-0 h-6 w-6"
                      aria-hidden="true"
                    />
                  )}
                  {item.name}
                </NavLink>
              ))}
            </nav>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Sidebar;
</file>

<file path="src/components/TaskCard.tsx">
import { useDraggable } from '@dnd-kit/core';
import { CSS } from '@dnd-kit/utilities';
import { PencilIcon, TrashIcon } from '@heroicons/react/24/outline';
import { Task } from '../types/task';
import { getFileTypeInfo } from '../utils/fileUtils';

interface TaskCardProps {
  task: Task;
  onEdit: (task: Task) => void;
  onDelete: (taskId: string) => void;
}

const TaskCard = ({ task, onEdit, onDelete }: TaskCardProps) => {
  const {
    attributes,
    listeners,
    setNodeRef,
    transform,
    isDragging,
  } = useDraggable({
    id: task.id,
  });

  const style = {
    transform: CSS.Transform.toString(transform),
    opacity: isDragging ? 0.5 : undefined,
  };

  return (
    <div
      ref={setNodeRef}
      style={style}
      {...attributes}
      {...listeners}
      className="relative bg-white p-4 rounded-md shadow-sm border border-gray-200 cursor-grab active:cursor-grabbing hover:shadow-md transition-shadow group"
    >
      {/* Add action buttons */}
      <div className="absolute top-2 right-2 flex gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
        <button
          onClick={(e) => {
            e.stopPropagation();
            onEdit(task);
          }}
          className="p-1 text-gray-400 hover:text-blue-500 rounded-full hover:bg-gray-100"
        >
          <PencilIcon className="h-4 w-4" />
        </button>
        <button
          onClick={(e) => {
            e.stopPropagation();
            onDelete(task.id);
          }}
          className="p-1 text-gray-400 hover:text-red-500 rounded-full hover:bg-gray-100"
        >
          <TrashIcon className="h-4 w-4" />
        </button>
      </div>

      {/* Task content */}
      <div className="flex justify-between items-start">
        <h3 className="text-sm font-medium text-gray-900">{task.title}</h3>
        <span className={`inline-flex items-center px-2 py-0.5 rounded text-xs font-medium ${
          task.priority === 'high' 
            ? 'bg-red-100 text-red-800'
            : task.priority === 'medium'
            ? 'bg-yellow-100 text-yellow-800'
            : 'bg-green-100 text-green-800'
        }`}>
          {task.priority}
        </span>
      </div>
      <p className="mt-1 text-sm text-gray-600 line-clamp-2">{task.description}</p>
      
      {task.dueDate && (
        <div className="mt-2 text-xs text-gray-500">
          Due: {new Date(task.dueDate).toLocaleDateString()}
        </div>
      )}
      
      {task.tags.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-1">
          {task.tags.map(tag => (
            <span
              key={tag}
              className="inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium bg-gray-100 text-gray-800"
            >
              {tag}
            </span>
          ))}
        </div>
      )}

      {/* Attachments section */}
      {task.attachments?.length > 0 && (
        <div className="mt-2 flex flex-wrap gap-2">
          {task.attachments.map(attachment => {
            const { icon: Icon, color } = getFileTypeInfo(attachment.fileType);
            return (
              <div
                key={attachment.id}
                className="inline-flex items-center text-xs text-gray-500"
                title={attachment.fileName}
              >
                <Icon className={`h-4 w-4 mr-1 ${color}`} />
                {attachment.fileName}
              </div>
            );
          })}
        </div>
      )}
    </div>
  );
};

export default TaskCard;
</file>

<file path="src/components/TaskColumn.tsx">
import { useDroppable } from '@dnd-kit/core';
import { TaskColumn as TaskColumnType, Task } from '../types/task';
import TaskCard from './TaskCard';

interface TaskColumnProps {
  column: TaskColumnType;
  onEditTask: (task: Task) => void;
  onDeleteTask: (taskId: string) => void;
}

const TaskColumn = ({ column, onEditTask, onDeleteTask }: TaskColumnProps) => {
  const { setNodeRef, isOver } = useDroppable({
    id: column.id,
  });

  return (
    <div className="flex-1 flex flex-col bg-gray-50 rounded-lg">
      <div className="p-4 font-medium text-gray-900 border-b border-gray-200">
        {column.title} ({column.tasks.length})
      </div>
      <div
        ref={setNodeRef}
        className={`flex-1 p-2 space-y-2 overflow-y-auto ${
          isOver ? 'bg-blue-50' : ''
        }`}
      >
        {column.tasks.map(task => (
          <TaskCard 
            key={task.id} 
            task={task} 
            onEdit={onEditTask}
            onDelete={onDeleteTask}
          />
        ))}
      </div>
    </div>
  );
};

export default TaskColumn;
</file>

<file path="src/components/TaskModal.tsx">
import { useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import { createTaskThunk, updateTaskThunk } from '../store/slices/taskSlice';
import { Task, TaskPriority, TaskStatus } from '../types/task';
import { XMarkIcon } from '@heroicons/react/24/outline';
import FileUpload from './attachments/FileUpload';
import AttachmentList from './attachments/AttachmentList';
import { RootState, useAppDispatch } from '../store';

interface TaskModalProps {
  isOpen: boolean;
  onClose: () => void;
  editTask?: Task;
}

const TaskModal = ({ isOpen, onClose, editTask }: TaskModalProps) => {
  const dispatch = useAppDispatch();
  const user = useSelector((state: RootState) => state.auth.user);
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    priority: 'medium' as TaskPriority,
    status: 'todo' as TaskStatus,
    dueDate: '',
    tags: '',
  });
  const [error, setError] = useState<string | null>(null);
  const [isSubmitting, setIsSubmitting] = useState(false);

  // Populate form when editing existing task
  useEffect(() => {
    if (editTask) {
      setFormData({
        title: editTask.title,
        description: editTask.description,
        priority: editTask.priority,
        status: editTask.status,
        dueDate: editTask.dueDate || '',
        tags: editTask.tags.join(', '),
      });
    } else {
      // Reset form when creating new task
      setFormData({
        title: '',
        description: '',
        priority: 'medium',
        status: 'todo',
        dueDate: '',
        tags: '',
      });
    }
  }, [editTask]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!user) {
      setError('You must be logged in to create or edit tasks');
      return;
    }
    
    setIsSubmitting(true);
    setError(null);
    
    try {
      const taskData: Task = {
        id: editTask?.id || crypto.randomUUID(),
        title: formData.title,
        description: formData.description,
        priority: formData.priority,
        status: formData.status,
        createdBy: editTask?.createdBy || user.uid,
        createdAt: editTask?.createdAt || new Date().toISOString(),
        dueDate: formData.dueDate || undefined,
        tags: formData.tags.split(',').map(tag => tag.trim()).filter(Boolean),
        attachments: editTask?.attachments || [],
        assignedTo: editTask?.assignedTo || user.uid, // Default to current user
      };

      if (editTask) {
        await dispatch(updateTaskThunk(taskData)).unwrap();
      } else {
        const { id, ...newTaskData } = taskData;
        await dispatch(createTaskThunk(newTaskData)).unwrap();
      }

      onClose();
    } catch (err) {
      setError((err as Error).message);
    } finally {
      setIsSubmitting(false);
    }
  };

  const handleFileError = (errorMessage: string) => {
    setError(errorMessage);
    // Clear error after 3 seconds
    setTimeout(() => setError(null), 3000);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 z-50 overflow-y-auto">
      <div className="flex items-center justify-center min-h-screen p-4 text-center">
        <div className="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity" onClick={onClose} />

        <div className="relative bg-white rounded-lg text-left overflow-hidden shadow-xl w-full max-w-lg">
          <div className="flex items-center justify-between p-4 border-b">
            <h3 className="text-lg font-medium">
              {editTask ? 'Edit Task' : 'Create New Task'}
            </h3>
            <button
              onClick={onClose}
              className="text-gray-400 hover:text-gray-500"
            >
              <XMarkIcon className="h-6 w-6" />
            </button>
          </div>

          <form onSubmit={handleSubmit} className="p-4">
            {error && (
              <div className="mb-4 p-2 bg-red-100 border border-red-400 text-red-700 rounded">
                {error}
              </div>
            )}
            
            <div className="space-y-4">
              <div>
                <label htmlFor="title" className="block text-sm font-medium text-gray-700">
                  Title
                </label>
                <input
                  type="text"
                  id="title"
                  required
                  className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-primary-500 focus:outline-none focus:ring-1 focus:ring-primary-500"
                  value={formData.title}
                  onChange={(e) => setFormData(prev => ({ ...prev, title: e.target.value }))}
                />
              </div>

              <div>
                <label htmlFor="description" className="block text-sm font-medium text-gray-700">
                  Description
                </label>
                <textarea
                  id="description"
                  rows={3}
                  className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-primary-500 focus:outline-none focus:ring-1 focus:ring-primary-500"
                  value={formData.description}
                  onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
                />
              </div>

              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label htmlFor="priority" className="block text-sm font-medium text-gray-700">
                    Priority
                  </label>
                  <select
                    id="priority"
                    className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-primary-500 focus:outline-none focus:ring-1 focus:ring-primary-500"
                    value={formData.priority}
                    onChange={(e) => setFormData(prev => ({ ...prev, priority: e.target.value as TaskPriority }))}
                  >
                    <option value="low">Low</option>
                    <option value="medium">Medium</option>
                    <option value="high">High</option>
                  </select>
                </div>

                <div>
                  <label htmlFor="status" className="block text-sm font-medium text-gray-700">
                    Status
                  </label>
                  <select
                    id="status"
                    className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-primary-500 focus:outline-none focus:ring-1 focus:ring-primary-500"
                    value={formData.status}
                    onChange={(e) => setFormData(prev => ({ ...prev, status: e.target.value as TaskStatus }))}
                  >
                    <option value="todo">To Do</option>
                    <option value="in_progress">In Progress</option>
                    <option value="in_review">In Review</option>
                    <option value="done">Done</option>
                  </select>
                </div>
              </div>

              <div>
                <label htmlFor="dueDate" className="block text-sm font-medium text-gray-700">
                  Due Date
                </label>
                <input
                  type="date"
                  id="dueDate"
                  className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-primary-500 focus:outline-none focus:ring-1 focus:ring-primary-500"
                  value={formData.dueDate}
                  onChange={(e) => setFormData(prev => ({ ...prev, dueDate: e.target.value }))}
                />
              </div>

              <div>
                <label htmlFor="tags" className="block text-sm font-medium text-gray-700">
                  Tags (comma-separated)
                </label>
                <input
                  type="text"
                  id="tags"
                  className="mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 text-sm focus:border-primary-500 focus:outline-none focus:ring-1 focus:ring-primary-500"
                  value={formData.tags}
                  onChange={(e) => setFormData(prev => ({ ...prev, tags: e.target.value }))}
                  placeholder="frontend, bug, feature"
                />
              </div>

              {editTask && (
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Attachments
                  </label>
                  <div className="mt-1">
                    <FileUpload
                      taskId={editTask.id}
                      onError={handleFileError}
                    />
                  </div>
                  {editTask.attachments && editTask.attachments.length > 0 && (
                    <AttachmentList
                      taskId={editTask.id}
                      attachments={editTask.attachments}
                    />
                  )}
                </div>
              )}
            </div>

            <div className="mt-6 flex justify-end space-x-3">
              <button
                type="button"
                onClick={onClose}
                className="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
                disabled={isSubmitting}
              >
                Cancel
              </button>
              <button
                type="submit"
                className="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-primary-600 hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
                disabled={isSubmitting}
              >
                {isSubmitting ? (
                  <span className="flex items-center">
                    <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    {editTask ? 'Updating...' : 'Creating...'}
                  </span>
                ) : (
                  editTask ? 'Update Task' : 'Create Task'
                )}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  );
};

export default TaskModal;
</file>

<file path="src/config/firebase.ts">
// Import the functions you need from the SDKs you need
import { initializeApp } from "firebase/app";
import { getAuth } from 'firebase/auth';
import { getStorage } from 'firebase/storage';
import { getFirestore } from 'firebase/firestore';

// TODO: Add SDKs for Firebase products that you want to use
// https://firebase.google.com/docs/web/setup#available-libraries

// Your web app's Firebase configuration
// For Firebase JS SDK v7.20.0 and later, measurementId is optional
const firebaseConfig = {
    apiKey: import.meta.env.VITE_FIREBASE_API_KEY,
    authDomain: import.meta.env.VITE_FIREBASE_AUTH_DOMAIN,
    projectId: import.meta.env.VITE_FIREBASE_PROJECT_ID,
    storageBucket: import.meta.env.VITE_FIREBASE_STORAGE_BUCKET,
    messagingSenderId: import.meta.env.VITE_FIREBASE_MESSAGING_SENDER_ID,
    appId: import.meta.env.VITE_FIREBASE_APP_ID
  };

// Initialize Firebase
const app = initializeApp(firebaseConfig);
export const auth = getAuth(app);
export const storage = getStorage(app);
export const db = getFirestore(app);

// Storage paths
export const STORAGE_PATHS = {
  TASK_ATTACHMENTS: 'task-attachments',
} as const;

// Firestore collection names
export const COLLECTIONS = {
  USERS: 'users',
  TASKS: 'tasks',
  CHATS: 'chats',
  MESSAGES: 'messages',
} as const;
</file>

<file path="src/hooks/useAuth.ts">
import { useState, useEffect } from 'react';
import { useDispatch } from 'react-redux';
import { 
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut,
  onAuthStateChanged,
  User as FirebaseUser
} from 'firebase/auth';
import { auth } from '../config/firebase';
import { setUser, setLoading, setError, logout } from '../store/slices/authSlice';
import { getUserData, createUserDocument, updateLastLogin } from '../services/userService';
import { User } from '../types/auth';

export const useAuth = () => {
  const dispatch = useDispatch();
  const [loading, setLocalLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {
      setLocalLoading(true);
      try {
        if (firebaseUser) {
          // Get user data from Firestore
          let userData = await getUserData(firebaseUser.uid);
          
          // If user document doesn't exist, create it
          if (!userData) {
            const newUser: User = {
              uid: firebaseUser.uid,
              email: firebaseUser.email,
              displayName: firebaseUser.displayName,
              photoURL: firebaseUser.photoURL,
              roles: { member: true }, // Default role
              createdAt: new Date().toISOString(),
              lastLogin: new Date().toISOString(),
            };
            
            await createUserDocument(newUser);
            userData = newUser;
          } else {
            // Update last login timestamp
            await updateLastLogin(firebaseUser.uid);
          }
          
          dispatch(setUser(userData));
        } else {
          dispatch(logout());
        }
      } catch (error) {
        console.error('Auth state change error:', error);
        dispatch(setError((error as Error).message));
      } finally {
        setLocalLoading(false);
      }
    });

    return () => unsubscribe();
  }, [dispatch]);

  const signUp = async (email: string, password: string) => {
    try {
      dispatch(setLoading(true));
      const userCredential = await createUserWithEmailAndPassword(auth, email, password);
      
      // Create user document in Firestore
      const newUser: User = {
        uid: userCredential.user.uid,
        email: userCredential.user.email,
        displayName: userCredential.user.displayName,
        photoURL: userCredential.user.photoURL,
        roles: { member: true }, // Default role
        createdAt: new Date().toISOString(),
        lastLogin: new Date().toISOString(),
      };
      
      await createUserDocument(newUser);
    } catch (error) {
      dispatch(setError((error as Error).message));
      throw error;
    }
  };

  const signIn = async (email: string, password: string) => {
    try {
      dispatch(setLoading(true));
      await signInWithEmailAndPassword(auth, email, password);
      // The onAuthStateChanged listener will handle updating the user state
    } catch (error) {
      dispatch(setError((error as Error).message));
      throw error;
    }
  };

  const signOutUser = async () => {
    try {
      await signOut(auth);
      dispatch(logout());
    } catch (error) {
      dispatch(setError((error as Error).message));
      throw error;
    }
  };

  return {
    signUp,
    signIn,
    signOut: signOutUser,
    loading,
  };
};
</file>

<file path="src/hooks/useTaskAttachment.ts">
import { useState, useCallback } from 'react';
import { useDispatch } from 'react-redux';
import { uploadTaskAttachment, deleteTaskAttachment, UploadProgress } from '../services/storageService';
import { addTaskAttachment, removeTaskAttachment } from '../store/slices/taskSlice';
import { validateFile } from '../utils/fileUtils';

export const useTaskAttachment = (taskId: string) => {
  const dispatch = useDispatch();
  const [uploadProgress, setUploadProgress] = useState<Record<string, UploadProgress>>({});

  const uploadFile = useCallback(async (file: File) => {
    const validation = validateFile(file);
    if (!validation.isValid) {
      throw new Error(validation.error);
    }

    try {
      const attachment = await uploadTaskAttachment(taskId, file, (progress) => {
        setUploadProgress(prev => ({
          ...prev,
          [file.name]: progress
        }));
      });

      dispatch(addTaskAttachment({ taskId, attachment }));
      return attachment;
    } catch (error) {
      throw error;
    }
  }, [taskId, dispatch]);

  const deleteFile = useCallback(async (attachmentId: string, fileName: string) => {
    try {
      await deleteTaskAttachment(taskId, fileName);
      dispatch(removeTaskAttachment({ taskId, attachmentId }));
    } catch (error) {
      throw error;
    }
  }, [taskId, dispatch]);

  return {
    uploadFile,
    deleteFile,
    uploadProgress
  };
};
</file>

<file path="src/index.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-gray-50 text-gray-900;
    margin: 0;
    min-height: 100vh;
  }
}

/*
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;

  color-scheme: light dark;
  color: rgba(255, 255, 255, 0.87);
  background-color: #242424;

  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

a {
  font-weight: 500;
  color: #646cff;
  text-decoration: inherit;
}
a:hover {
  color: #535bf2;
}

body {
  margin: 0;
  display: flex;
  place-items: center;
  min-width: 320px;
  min-height: 100vh;
}

h1 {
  font-size: 3.2em;
  line-height: 1.1;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

@media (prefers-color-scheme: light) {
  :root {
    color: #213547;
    background-color: #ffffff;
  }
  a:hover {
    color: #747bff;
  }
  button {
    background-color: #f9f9f9;
  }
}

*/
</file>

<file path="src/main.tsx">
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)
</file>

<file path="src/pages/Dashboard.tsx">
const Dashboard = () => {
    return (
      <div className="py-4">
        <h1 className="text-2xl font-semibold text-gray-900">Dashboard</h1>
        <div className="mt-4">
          <p className="text-gray-500">Welcome to the collaboration platform!</p>
        </div>
      </div>
    );
  };
  
  export default Dashboard;
</file>

<file path="src/pages/Tasks.tsx">
import { useMemo, useState, useEffect } from 'react';
import { useSelector } from 'react-redux';
import { 
  DndContext, 
  DragEndEvent, 
  useSensor,
  useSensors,
  PointerSensor,
  MouseSensor,
} from '@dnd-kit/core';
import { RootState, useAppDispatch } from '../store';
import { TaskColumn as TaskColumnType, Task, TaskStatus } from '../types/task';
import TaskColumn from '../components/TaskColumn';
import TaskModal from '../components/TaskModal';
import { 
  fetchTasks, 
  updateTaskStatusThunk, 
  deleteTaskThunk
} from '../store/slices/taskSlice';

const COLUMN_CONFIG: { id: TaskStatus; title: string }[] = [
  { id: 'todo', title: 'To Do' },
  { id: 'in_progress', title: 'In Progress' },
  { id: 'in_review', title: 'In Review' },
  { id: 'done', title: 'Done' },
];

const TasksPage = () => {
  // Use typed dispatch
  const dispatch = useAppDispatch();
  const { tasks, loading, error } = useSelector((state: RootState) => state.tasks);
  const user = useSelector((state: RootState) => state.auth.user);
  const [isModalOpen, setIsModalOpen] = useState(false);
  const [editingTask, setEditingTask] = useState<Task | undefined>(undefined);
  
  const sensors = useSensors(
    useSensor(MouseSensor),
    useSensor(PointerSensor, {
      activationConstraint: {
        distance: 8,
      },
    })
  );

  const columns: TaskColumnType[] = useMemo(() => {
    return COLUMN_CONFIG.map(col => ({
      ...col,
      tasks: tasks.filter(task => task.status === col.id),
    }));
  }, [tasks]);

  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event;
    
    if (!over) return;

    const taskId = active.id as string;
    const newStatus = over.id as TaskStatus;

    if (newStatus && taskId) {
      dispatch(updateTaskStatusThunk({ taskId, status: newStatus }));
    }
  };

  const handleEditTask = (task: Task) => {
    setEditingTask(task);
    setIsModalOpen(true);
  };

  const handleDeleteTask = (taskId: string) => {
    if (window.confirm('Are you sure you want to delete this task?')) {
      dispatch(deleteTaskThunk(taskId));
    }
  };

  const handleCloseModal = () => {
    setIsModalOpen(false);
    setEditingTask(undefined);
  };

  if (loading && tasks.length === 0) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary-600"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 mb-4" role="alert">
        <p className="font-bold">Error</p>
        <p>{error}</p>
      </div>
    );
  }

  return (
    <div className="h-full flex flex-col">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-semibold text-gray-900">Tasks</h1>
        <button
          type="button"
          onClick={() => setIsModalOpen(true)}
          className="px-4 py-2 bg-primary-600 text-white rounded-md hover:bg-primary-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500"
        >
          Create Task
        </button>
      </div>
      
      <div className="flex-1 flex gap-4 min-h-0">
        <DndContext 
          sensors={sensors}
          onDragEnd={handleDragEnd}
        >
          {columns.map(column => (
            <TaskColumn 
              key={column.id} 
              column={column}
              onEditTask={handleEditTask}
              onDeleteTask={handleDeleteTask}
            />
          ))}
        </DndContext>
      </div>

      <TaskModal 
        isOpen={isModalOpen}
        onClose={handleCloseModal}
        editTask={editingTask}
      />
    </div>
  );
};

export default TasksPage;
</file>

<file path="src/services/__tests__/storageService.test.ts">
import { uploadTaskAttachment, deleteTaskAttachment } from '../storageService';
import { storage } from '../../config/firebase';

jest.mock('../../config/firebase', () => ({
  storage: {
    ref: jest.fn(),
  },
  STORAGE_PATHS: {
    TASK_ATTACHMENTS: 'task-attachments'
  }
}));

describe('Storage Service', () => {
  it('should upload file and return attachment data', async () => {
    const mockFile = new File(['test'], 'test.txt', { type: 'text/plain' });
    const mockProgress = jest.fn();

    const attachment = await uploadTaskAttachment('task-1', mockFile, mockProgress);

    expect(attachment).toHaveProperty('id');
    expect(attachment.fileName).toBe('test.txt');
    expect(mockProgress).toHaveBeenCalled();
  });
});
</file>

<file path="src/services/chatService.ts">
import { 
  collection,
  doc,
  addDoc,
  getDoc,
  getDocs,
  updateDoc,
  deleteDoc,
  query,
  where,
  onSnapshot,
  orderBy,
  limit,
  serverTimestamp,
  Timestamp
} from 'firebase/firestore';
import { db, COLLECTIONS } from '../config/firebase';
import { Chat, Message, ChatType } from '../types/chat';

// Helper function to safely convert Firestore timestamps to ISO strings
const convertTimestampToString = (timestamp: any): string | undefined => {
  if (!timestamp) return undefined;
  
  // Handle Firestore Timestamp
  if (timestamp.toDate && typeof timestamp.toDate === 'function') {
    return timestamp.toDate().toISOString();
  }
  
  // Handle Date objects
  if (timestamp instanceof Date) {
    return timestamp.toISOString();
  }
  
  // Already a string
  if (typeof timestamp === 'string') {
    return timestamp;
  }
  
  return undefined;
};

// Chat converter
const chatConverter = {
  fromFirestore: (snapshot: any, options?: any) => {
    const data = snapshot.data(options);
    
    // Process the lastMessage if it exists
    let lastMessage = data.lastMessage;
    if (lastMessage) {
      lastMessage = {
        ...lastMessage,
        timestamp: convertTimestampToString(lastMessage.timestamp)
      };
    }
    
    return {
      ...data,
      id: snapshot.id,
      lastUpdated: convertTimestampToString(data.lastUpdated) || new Date().toISOString(),
      createdAt: convertTimestampToString(data.createdAt),
      lastMessage
    } as Chat;
  },
  toFirestore: (chat: Partial<Chat>) => {
    const { id, ...chatData } = chat;
    
    // Only convert lastMessage timestamp if it exists
    const lastMessage = chat.lastMessage ? {
      ...chat.lastMessage,
      timestamp: chat.lastMessage.timestamp ? 
        Timestamp.fromDate(new Date(chat.lastMessage.timestamp)) : 
        serverTimestamp()
    } : undefined;
    
    return {
      ...chatData,
      lastMessage,
      lastUpdated: serverTimestamp()
    };
  }
};

// Message converter
const messageConverter = {
  fromFirestore: (snapshot: any, options?: any) => {
    const data = snapshot.data(options);
    return {
      ...data,
      id: snapshot.id,
      timestamp: convertTimestampToString(data.timestamp) || new Date().toISOString(),
    } as Message;
  },
  toFirestore: (message: Omit<Message, 'id'>) => {
    return {
      ...message,
      timestamp: message.timestamp ? 
        Timestamp.fromDate(new Date(message.timestamp)) : 
        serverTimestamp()
    };
  }
};

// Create a new chat
export const createChat = async (chat: Omit<Chat, 'id'>): Promise<Chat> => {
  const chatsCollection = collection(db, COLLECTIONS.CHATS);
  const chatData = {
    ...chat,
    createdAt: serverTimestamp(),
    lastUpdated: serverTimestamp()
  };
  
  const docRef = await addDoc(chatsCollection, chatData);
  
  // Fetch the created document to properly convert timestamps
  const chatDoc = await getDoc(docRef);
  return chatConverter.fromFirestore(chatDoc);
};

// Get chat by ID
export const getChatById = async (chatId: string): Promise<Chat | null> => {
  const chatDoc = doc(db, COLLECTIONS.CHATS, chatId);
  const snapshot = await getDoc(chatDoc);
  
  if (!snapshot.exists()) {
    return null;
  }
  
  return chatConverter.fromFirestore(snapshot);
};

// Get all chats for a user
export const getUserChats = async (userId: string): Promise<Chat[]> => {
  const chatsCollection = collection(db, COLLECTIONS.CHATS);
  const q = query(
    chatsCollection,
    where('participants', 'array-contains', userId),
    orderBy('lastUpdated', 'desc')
  );
  
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => chatConverter.fromFirestore(doc));
};

// Subscribe to user chats
export const subscribeToUserChats = (userId: string, callback: (chats: Chat[]) => void) => {
  const chatsCollection = collection(db, COLLECTIONS.CHATS);
  const q = query(
    chatsCollection,
    where('participants', 'array-contains', userId),
    orderBy('lastUpdated', 'desc')
  );
  
  return onSnapshot(q, (snapshot) => {
    const chats = snapshot.docs.map(doc => chatConverter.fromFirestore(doc));
    callback(chats);
  });
};

// Create a message
export const sendMessage = async (chatId: string, message: Omit<Message, 'id'>): Promise<Message> => {
  const messagesCollection = collection(db, COLLECTIONS.CHATS, chatId, COLLECTIONS.MESSAGES);
  const docRef = await addDoc(messagesCollection, messageConverter.toFirestore(message));
  
  // Update chat's lastUpdated and lastMessage
  const chatDoc = doc(db, COLLECTIONS.CHATS, chatId);
  await updateDoc(chatDoc, {
    lastUpdated: serverTimestamp(),
    lastMessage: {
      content: message.content,
      senderId: message.senderId,
      timestamp: serverTimestamp(),
      type: message.type
    }
  });
  
  // Get the created message with proper timestamp conversion
  const messageDoc = await getDoc(docRef);
  return messageConverter.fromFirestore(messageDoc);
};

// Get messages for a chat
export const getChatMessages = async (chatId: string, msgLimit = 50): Promise<Message[]> => {
  const messagesCollection = collection(db, COLLECTIONS.CHATS, chatId, COLLECTIONS.MESSAGES);
  const q = query(
    messagesCollection,
    orderBy('timestamp', 'desc'),
    limit(msgLimit)
  );
  
  const snapshot = await getDocs(q);
  return snapshot.docs
    .map(doc => messageConverter.fromFirestore(doc))
    .reverse(); // Reverse to get oldest messages first
};

// Subscribe to chat messages
export const subscribeToChatMessages = (
  chatId: string, 
  callback: (messages: Message[]) => void,
  messageLimit = 50
) => {
  const messagesCollection = collection(db, COLLECTIONS.CHATS, chatId, COLLECTIONS.MESSAGES);
  const q = query(
    messagesCollection,
    orderBy('timestamp', 'asc'),
    limit(messageLimit)
  );
  
  return onSnapshot(q, (snapshot) => {
    const messages = snapshot.docs.map(doc => messageConverter.fromFirestore(doc));
    callback(messages);
  });
};

// Create a direct message chat between two users
export const createDirectMessageChat = async (
  userId1: string,
  userId2: string,
  userName1: string,
  userName2: string
): Promise<Chat> => {
  // Check if chat already exists
  const chatsCollection = collection(db, COLLECTIONS.CHATS);
  const q = query(
    chatsCollection,
    where('type', '==', 'direct'),
    where('participants', 'array-contains', userId1)
  );
  
  const snapshot = await getDocs(q);
  const existingChat = snapshot.docs.find(doc => {
    const data = doc.data();
    return data.participants.includes(userId2);
  });
  
  if (existingChat) {
    return chatConverter.fromFirestore(existingChat);
  }
  
  // Create new direct message chat
  return createChat({
    type: 'direct',
    name: `${userName1}, ${userName2}`,
    participants: [userId1, userId2],
    meta: {
      userNames: {
        [userId1]: userName1,
        [userId2]: userName2
      }
    }
  });
};

// Create a channel chat
export const createChannelChat = async (
  name: string,
  description: string,
  creatorId: string
): Promise<Chat> => {
  return createChat({
    type: 'channel',
    name,
    description,
    participants: [creatorId],
    meta: {
      createdBy: creatorId
    }
  });
};

// Add user to chat
export const addUserToChat = async (chatId: string, userId: string): Promise<void> => {
  const chatDoc = doc(db, COLLECTIONS.CHATS, chatId);
  const chatSnapshot = await getDoc(chatDoc);
  
  if (!chatSnapshot.exists()) {
    throw new Error('Chat not found');
  }
  
  const chatData = chatSnapshot.data();
  const participants = chatData.participants || [];
  
  if (!participants.includes(userId)) {
    await updateDoc(chatDoc, {
      participants: [...participants, userId],
      lastUpdated: serverTimestamp()
    });
  }
};

// Remove user from chat
export const removeUserFromChat = async (chatId: string, userId: string): Promise<void> => {
  const chatDoc = doc(db, COLLECTIONS.CHATS, chatId);
  const chatSnapshot = await getDoc(chatDoc);
  
  if (!chatSnapshot.exists()) {
    throw new Error('Chat not found');
  }
  
  const chatData = chatSnapshot.data();
  const participants = chatData.participants || [];
  
  await updateDoc(chatDoc, {
    participants: participants.filter((id: string) => id !== userId),
    lastUpdated: serverTimestamp()
  });
};
</file>

<file path="src/services/createChannel.ts">
import { 
    collection,
    doc,
    setDoc,
    getDoc,
    serverTimestamp
  } from 'firebase/firestore';
  import { db, COLLECTIONS } from '../config/firebase';
  import { Chat } from '../types/chat';
  
  // Helper function to safely convert Firestore timestamps to ISO strings
  const convertTimestampToString = (timestamp: any): string | undefined => {
    if (!timestamp) return undefined;
    
    // Handle Firestore Timestamp
    if (timestamp.toDate && typeof timestamp.toDate === 'function') {
      return timestamp.toDate().toISOString();
    }
    
    // Handle Date objects
    if (timestamp instanceof Date) {
      return timestamp.toISOString();
    }
    
    // Already a string
    if (typeof timestamp === 'string') {
      return timestamp;
    }
    
    return undefined;
  };
  
  /**
   * Create a new channel chat with extra error handling and debugging
   */
  export const createChannelChatEnhanced = async (
    name: string,
    description: string,
    creatorId: string
  ): Promise<Chat> => {
    console.log('Starting enhanced channel creation:', { name, description, creatorId });
  
    try {
      // Create a reference for a new document with an auto-generated ID
      const chatsCollection = collection(db, COLLECTIONS.CHATS);
      const newChatRef = doc(chatsCollection);
      const chatId = newChatRef.id;
      
      console.log('Generated new chat ID:', chatId);
      
      // Prepare the chat data
      const chatData = {
        id: chatId,
        type: 'channel' as const,
        name,
        description,
        participants: [creatorId],
        meta: {
          createdBy: creatorId
        },
        createdAt: serverTimestamp(),
        lastUpdated: serverTimestamp()
      };
      
      // Remove the ID field before storing (it's already in the document reference)
      const { id, ...dataToStore } = chatData;
      
      // Use setDoc instead of addDoc for more control
      await setDoc(newChatRef, dataToStore);
      console.log('Chat document created successfully');
      
      // Retrieve the new document to get server timestamps
      const docSnapshot = await getDoc(newChatRef);
      
      if (!docSnapshot.exists()) {
        throw new Error('Failed to retrieve newly created chat document');
      }
      
      const data = docSnapshot.data();
      console.log('Retrieved chat data:', data);
      
      // Convert timestamps to strings for Redux
      const result: Chat = {
        id: chatId,
        type: 'channel',
        name: data.name,
        description: data.description,
        participants: data.participants,
        meta: data.meta,
        createdAt: convertTimestampToString(data.createdAt),
        lastUpdated: convertTimestampToString(data.lastUpdated) || new Date().toISOString(),
      };
      
      console.log('Returning serialized chat object:', result);
      return result;
    } catch (error) {
      console.error('Error in enhanced channel creation:', error);
      throw error;
    }
  };
</file>

<file path="src/services/storageService.ts">
import { 
    ref, 
    uploadBytesResumable, 
    getDownloadURL, 
    deleteObject,
    StorageReference 
  } from 'firebase/storage';
  import { storage, STORAGE_PATHS } from '../config/firebase';
  import { TaskAttachment } from '../types/attachment';
  
  export interface UploadProgress {
    progress: number;
    downloadUrl?: string;
    error?: string;
  }
  
  export const getStorageRef = (taskId: string, fileName: string): StorageReference => {
    return ref(storage, `${STORAGE_PATHS.TASK_ATTACHMENTS}/${taskId}/${fileName}`);
  };
  
  export const uploadTaskAttachment = (
    taskId: string,
    file: File,
    onProgress?: (progress: UploadProgress) => void
  ): Promise<TaskAttachment> => {
    return new Promise((resolve, reject) => {
      const fileName = `${Date.now()}-${file.name}`;
      const storageRef = getStorageRef(taskId, fileName);
      const uploadTask = uploadBytesResumable(storageRef, file);
  
      uploadTask.on(
        'state_changed',
        (snapshot) => {
          const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
          onProgress?.({ progress });
        },
        (error) => {
          onProgress?.({ progress: 0, error: error.message });
          reject(error);
        },
        async () => {
          try {
            const downloadUrl = await getDownloadURL(uploadTask.snapshot.ref);
            const attachment: TaskAttachment = {
              id: fileName,
              taskId,
              fileName: file.name,
              fileType: file.type,
              fileSize: file.size,
              uploadedBy: 'user1', // TODO: Get from auth context
              uploadedAt: new Date().toISOString(),
              downloadUrl,
            };
            onProgress?.({ progress: 100, downloadUrl });
            resolve(attachment);
          } catch (error) {
            reject(error);
          }
        }
      );
    });
  };
  
  export const deleteTaskAttachment = async (taskId: string, fileName: string): Promise<void> => {
    const storageRef = getStorageRef(taskId, fileName);
    await deleteObject(storageRef);
  };
</file>

<file path="src/services/taskService.ts">
import { 
  collection,
  doc,
  setDoc,
  getDoc,
  getDocs,
  updateDoc,
  deleteDoc,
  query,
  where,
  onSnapshot,
  Timestamp,
  serverTimestamp,
  orderBy
} from 'firebase/firestore';
import { db, COLLECTIONS } from '../config/firebase';
import { Task, TaskStatus } from '../types/task';

// Helper function to safely convert Firestore timestamps to ISO strings
const convertTimestampToString = (timestamp: any): string | undefined => {
  if (!timestamp) return undefined;
  
  // Handle Firestore Timestamp
  if (timestamp.toDate && typeof timestamp.toDate === 'function') {
    return timestamp.toDate().toISOString();
  }
  
  // Handle Date objects
  if (timestamp instanceof Date) {
    return timestamp.toISOString();
  }
  
  // Already a string
  if (typeof timestamp === 'string') {
    return timestamp;
  }
  
  return undefined;
};

// Convert Firestore data to Task object
const taskConverter = {
  fromFirestore: (snapshot: any, options?: any) => {
    const data = snapshot.data(options);
    
    // Safely handle all timestamp fields
    return {
      ...data,
      id: snapshot.id,
      createdAt: convertTimestampToString(data.createdAt) || new Date().toISOString(),
      dueDate: convertTimestampToString(data.dueDate),
      updatedAt: convertTimestampToString(data.updatedAt),
      // Ensure attachments have proper date formatting
      attachments: Array.isArray(data.attachments) 
        ? data.attachments.map((attachment: any) => ({
            ...attachment,
            uploadedAt: convertTimestampToString(attachment.uploadedAt) || new Date().toISOString()
          }))
        : []
    } as Task;
  },
  toFirestore: (task: Task) => {
    const { id, ...taskData } = task;
    return {
      ...taskData,
      createdAt: task.createdAt ? Timestamp.fromDate(new Date(task.createdAt)) : serverTimestamp(),
      dueDate: task.dueDate ? Timestamp.fromDate(new Date(task.dueDate)) : null,
      updatedAt: serverTimestamp(),
    };
  }
};

// Create a new task
export const createTask = async (task: Omit<Task, 'id'>): Promise<Task> => {
  const tasksCollection = collection(db, COLLECTIONS.TASKS);
  const docRef = doc(tasksCollection);
  const newTask = { ...task, id: docRef.id };
  
  await setDoc(docRef, taskConverter.toFirestore(newTask));
  
  // Get the document back to ensure timestamps are converted
  const snapshot = await getDoc(docRef);
  return taskConverter.fromFirestore(snapshot);
};

// Get a task by ID
export const getTaskById = async (taskId: string): Promise<Task | null> => {
  const taskDoc = doc(db, COLLECTIONS.TASKS, taskId);
  const snapshot = await getDoc(taskDoc);
  
  if (!snapshot.exists()) {
    return null;
  }
  
  return taskConverter.fromFirestore(snapshot);
};

// Get all tasks
export const getAllTasks = async (): Promise<Task[]> => {
  const tasksCollection = collection(db, COLLECTIONS.TASKS);
  const q = query(tasksCollection, orderBy('createdAt', 'desc'));
  const snapshot = await getDocs(q);
  
  return snapshot.docs.map(doc => taskConverter.fromFirestore(doc));
};

// Update a task
export const updateTaskInFirestore = async (task: Task): Promise<void> => {
  const taskDoc = doc(db, COLLECTIONS.TASKS, task.id);
  await updateDoc(taskDoc, taskConverter.toFirestore(task));
};

// Delete a task
export const deleteTaskFromFirestore = async (taskId: string): Promise<void> => {
  const taskDoc = doc(db, COLLECTIONS.TASKS, taskId);
  await deleteDoc(taskDoc);
};

// Update task status
export const updateTaskStatusInFirestore = async (taskId: string, status: TaskStatus): Promise<void> => {
  const taskDoc = doc(db, COLLECTIONS.TASKS, taskId);
  await updateDoc(taskDoc, { 
    status,
    updatedAt: serverTimestamp()
  });
};

// Subscribe to tasks changes
export const subscribeToTasks = (callback: (tasks: Task[]) => void) => {
  const tasksCollection = collection(db, COLLECTIONS.TASKS);
  const q = query(tasksCollection, orderBy('createdAt', 'desc'));
  
  return onSnapshot(q, (snapshot) => {
    const tasks = snapshot.docs.map(doc => taskConverter.fromFirestore(doc));
    callback(tasks);
  });
};

// Get tasks by status
export const getTasksByStatus = async (status: TaskStatus): Promise<Task[]> => {
  const tasksCollection = collection(db, COLLECTIONS.TASKS);
  const q = query(
    tasksCollection,
    where('status', '==', status),
    orderBy('createdAt', 'desc')
  );
  
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => taskConverter.fromFirestore(doc));
};

// Get tasks by assignee
export const getTasksByAssignee = async (userId: string): Promise<Task[]> => {
  const tasksCollection = collection(db, COLLECTIONS.TASKS);
  const q = query(
    tasksCollection,
    where('assignedTo', '==', userId),
    orderBy('createdAt', 'desc')
  );
  
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => taskConverter.fromFirestore(doc));
};
</file>

<file path="src/services/userService.ts">
import { 
  doc,
  setDoc,
  getDoc,
  updateDoc,
  serverTimestamp
} from 'firebase/firestore';
import { db, COLLECTIONS } from '../config/firebase';
import { User, UserRole } from '../types/auth';

// Helper function to safely convert Firestore timestamps to ISO strings
const convertTimestampToString = (timestamp: any): string | undefined => {
  if (!timestamp) return undefined;
  
  // Handle Firestore Timestamp
  if (timestamp.toDate && typeof timestamp.toDate === 'function') {
    return timestamp.toDate().toISOString();
  }
  
  // Handle Date objects
  if (timestamp instanceof Date) {
    return timestamp.toISOString();
  }
  
  // Already a string
  if (typeof timestamp === 'string') {
    return timestamp;
  }
  
  return undefined;
};

// Create a new user document
export const createUserDocument = async (user: User): Promise<void> => {
  const userRef = doc(db, COLLECTIONS.USERS, user.uid);
  const userData = {
    uid: user.uid,
    email: user.email,
    displayName: user.displayName || null,
    photoURL: user.photoURL || null,
    roles: user.roles || { member: true },
    createdAt: serverTimestamp(),
    lastLogin: serverTimestamp()
  };
  
  await setDoc(userRef, userData);
};

// Get user data
export const getUserData = async (userId: string): Promise<User | null> => {
  const userDoc = doc(db, COLLECTIONS.USERS, userId);
  const snapshot = await getDoc(userDoc);
  
  if (!snapshot.exists()) {
    return null;
  }
  
  const data = snapshot.data();
  return {
    uid: snapshot.id,
    email: data.email,
    displayName: data.displayName,
    photoURL: data.photoURL,
    roles: data.roles,
    createdAt: convertTimestampToString(data.createdAt) || new Date().toISOString(),
    lastLogin: convertTimestampToString(data.lastLogin) || new Date().toISOString(),
  };
};

// Update user profile
export const updateUserProfile = async (
  userId: string, 
  data: { displayName?: string; photoURL?: string }
): Promise<void> => {
  const userDoc = doc(db, COLLECTIONS.USERS, userId);
  await updateDoc(userDoc, {
    ...data,
    updatedAt: serverTimestamp()
  });
};

// Update user roles
export const updateUserRoles = async (
  userId: string,
  roles: UserRole
): Promise<void> => {
  const userDoc = doc(db, COLLECTIONS.USERS, userId);
  await updateDoc(userDoc, {
    roles,
    updatedAt: serverTimestamp()
  });
};

// Update last login timestamp
export const updateLastLogin = async (userId: string): Promise<void> => {
  const userDoc = doc(db, COLLECTIONS.USERS, userId);
  await updateDoc(userDoc, {
    lastLogin: serverTimestamp()
  });
};
</file>

<file path="src/setupTests.ts">
import '@testing-library/jest-dom';
</file>

<file path="src/store/index.ts">
import { configureStore } from '@reduxjs/toolkit';
import taskReducer from './slices/taskSlice';
import chatReducer from './slices/chatSlice';
import authReducer from './slices/authSlice';
import { useDispatch } from 'react-redux';
import { isPlainObject } from '@reduxjs/toolkit';

// Custom serializable check function to handle Firestore timestamps
const isFirestoreTimestamp = (value: any): boolean => {
  return (
    value !== null &&
    typeof value === 'object' &&
    typeof value.seconds === 'number' &&
    typeof value.nanoseconds === 'number' &&
    value.toDate &&
    typeof value.toDate === 'function'
  );
};

export const store = configureStore({
  reducer: {
    tasks: taskReducer,
    chat: chatReducer,
    auth: authReducer,
  },
  middleware: (getDefaultMiddleware) =>
    getDefaultMiddleware({
      serializableCheck: {
        // Ignore these specific action types
        ignoredActions: [
          // Add any action types to ignore here
        ],
        
        // Function to check if a value is serializable
        isSerializable: (value: any) => {
          // Allow Firebase timestamps to pass through
          if (isFirestoreTimestamp(value)) {
            return true;
          }
          
          // Use the default serializable checks for other values
          if (typeof value === 'function' || value instanceof Promise || value instanceof RegExp) {
            return false;
          }
          
          if (value instanceof Date) {
            return true;
          }
          
          if (value instanceof Error) {
            return true;
          }
          
          if (value instanceof Map || value instanceof Set) {
            return false;
          }
          
          if (isPlainObject(value) || Array.isArray(value)) {
            return true;
          }
          
          return typeof value === 'boolean' || 
                typeof value === 'number' || 
                typeof value === 'string' || 
                value === null || 
                value === undefined;
        },
      },
    }),
});

export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;
export const useAppDispatch = () => useDispatch<AppDispatch>();
</file>

<file path="src/store/middleware/socketMiddleware.ts">
import { Middleware } from '@reduxjs/toolkit';
import { socketService } from '../../services/socket';

export const socketMiddleware: Middleware = (store) => (next) => (action) => {
  // Handle socket-specific actions
  if (action.type === 'chat/sendMessage') {
    const { chatId, message } = action.payload;
    socketService.sendMessage(chatId, message.content);
  }

  // Always pass the action to the next middleware
  return next(action);
};
</file>

<file path="src/store/slices/__tests__/authSlice.test.ts">
import authReducer, { setUser, setLoading, setError, logout } from '../authSlice';
import { User } from '../../../types/auth';

describe('authSlice', () => {
  const initialState = {
    user: null,
    loading: false,
    error: null,
  };

  const mockUser: User = {
    uid: '123',
    email: 'test@test.com',
    displayName: 'Test User',
    roles: { member: true },
    createdAt: '2025-01-30T00:00:00.000Z',
    lastLogin: '2025-01-30T00:00:00.000Z',
  };

  it('should handle initial state', () => {
    expect(authReducer(undefined, { type: 'unknown' })).toEqual(initialState);
  });

  it('should handle setUser', () => {
    const actual = authReducer(initialState, setUser(mockUser));
    expect(actual.user).toEqual(mockUser);
    expect(actual.loading).toBe(false);
    expect(actual.error).toBeNull();
  });

  it('should handle setLoading', () => {
    const actual = authReducer(initialState, setLoading(true));
    expect(actual.loading).toBe(true);
  });

  it('should handle setError', () => {
    const errorMessage = 'Test error';
    const actual = authReducer(initialState, setError(errorMessage));
    expect(actual.error).toBe(errorMessage);
    expect(actual.loading).toBe(false);
  });

  it('should handle logout', () => {
    const stateWithUser = {
      user: mockUser,
      loading: false,
      error: null,
    };
    const actual = authReducer(stateWithUser, logout());
    expect(actual).toEqual(initialState);
  });
});
</file>

<file path="src/store/slices/__tests__/taskSlice.test.ts">
import taskReducer, { 
    addTask, 
    updateTask, 
    updateTaskStatus, 
    deleteTask 
  } from '../taskSlice';
  import { Task } from '../../../types/task';
  
  describe('taskSlice', () => {
    const initialState = {
      tasks: [],
      loading: false,
      error: null,
    };
  
    const sampleTask: Task = {
      id: '1',
      title: 'Test Task',
      description: 'Test Description',
      status: 'todo',
      priority: 'medium',
      createdBy: 'user1',
      createdAt: new Date().toISOString(),
      tags: ['test'],
      attachments: [],
    };
  
    it('should handle initial state', () => {
      expect(taskReducer(undefined, { type: 'unknown' })).toEqual({
        tasks: expect.any(Array),
        loading: false,
        error: null,
      });
    });
  
    it('should handle addTask', () => {
      const actual = taskReducer(initialState, addTask(sampleTask));
      expect(actual.tasks).toHaveLength(1);
      expect(actual.tasks[0]).toEqual(sampleTask);
    });
  
    it('should handle updateTask', () => {
      const state = {
        ...initialState,
        tasks: [sampleTask],
      };
  
      const updatedTask = {
        ...sampleTask,
        title: 'Updated Title',
      };
  
      const actual = taskReducer(state, updateTask(updatedTask));
      expect(actual.tasks[0].title).toEqual('Updated Title');
    });
  
    it('should handle updateTaskStatus', () => {
      const state = {
        ...initialState,
        tasks: [sampleTask],
      };
  
      const actual = taskReducer(
        state,
        updateTaskStatus({ taskId: '1', status: 'in_progress' })
      );
      expect(actual.tasks[0].status).toEqual('in_progress');
    });
  
    it('should handle deleteTask', () => {
      const state = {
        ...initialState,
        tasks: [sampleTask],
      };
  
      const actual = taskReducer(state, deleteTask('1'));
      expect(actual.tasks).toHaveLength(0);
    });
  });
</file>

<file path="src/store/slices/authSlice.ts">
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { User, AuthState } from '../../types/auth';

const initialState: AuthState = {
  user: null,
  loading: false,
  error: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    setUser: (state, action: PayloadAction<User | null>) => {
      state.user = action.payload;
      state.loading = false;
      state.error = null;
    },
    setLoading: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload;
    },
    setError: (state, action: PayloadAction<string | null>) => {
      state.error = action.payload;
      state.loading = false;
    },
    logout: (state) => {
      state.user = null;
      state.loading = false;
      state.error = null;
    },
  },
});

export const { setUser, setLoading, setError, logout } = authSlice.actions;
export default authSlice.reducer;
</file>

<file path="src/store/slices/chatSlice.ts">
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import { Chat, Message, ChatState } from '../../types/chat';
import {
  getUserChats,
  getChatMessages,
  sendMessage as sendMessageToFirestore,
  createDirectMessageChat,
  subscribeToUserChats,
  subscribeToChatMessages
} from '../../services/chatService';
import { createChannelChatEnhanced } from '../../services/createChannel';
import { 
  registerSubscription, 
  unregisterSubscription,
  unregisterSubscriptionsByPrefix
} from '../../utils/subscriptionManager';

const initialState: ChatState = {
  activeChats: [],
  messages: {},
  currentChatId: null,
  loading: false,
  error: null,
};

// Async Thunks
export const fetchUserChats = createAsyncThunk(
  'chat/fetchUserChats',
  async (userId: string, { dispatch, rejectWithValue }) => {
    try {
      console.log('Fetching chats for user:', userId);
      const chats = await getUserChats(userId);
      console.log('Fetched chats:', chats);
      
      // Setup real-time subscription using the subscription manager
      const unsubscribe = subscribeToUserChats(userId, (updatedChats) => {
        console.log('Real-time chat update received:', updatedChats);
        dispatch(setChats(updatedChats));
      });
      
      // Store the unsubscribe function in our manager, not in Redux state
      registerSubscription('chats', unsubscribe);
      
      return chats;
    } catch (error) {
      console.error('Error fetching chats:', error);
      return rejectWithValue((error as Error).message);
    }
  }
);

export const fetchChatMessages = createAsyncThunk(
  'chat/fetchChatMessages',
  async (chatId: string, { dispatch, rejectWithValue }) => {
    try {
      // Clean up any existing message subscription first
      unregisterSubscription(`messages-${chatId}`);
      
      const messages = await getChatMessages(chatId);
      
      // Setup real-time subscription for this chat's messages
      const unsubscribe = subscribeToChatMessages(chatId, (updatedMessages) => {
        dispatch(setMessages({ chatId, messages: updatedMessages }));
      });
      
      // Store the unsubscribe function in our manager, not in Redux state
      registerSubscription(`messages-${chatId}`, unsubscribe);
      
      return { chatId, messages };
    } catch (error) {
      console.error('Error fetching messages:', error);
      return rejectWithValue((error as Error).message);
    }
  }
);

export const sendMessage = createAsyncThunk(
  'chat/sendMessage',
  async ({ chatId, content, senderId }: { chatId: string; content: string; senderId: string }, { rejectWithValue }) => {
    try {
      const newMessage: Omit<Message, 'id'> = {
        content,
        type: 'text',
        senderId,
        timestamp: new Date().toISOString(),
      };
      
      const sentMessage = await sendMessageToFirestore(chatId, newMessage);
      return { chatId, message: sentMessage };
    } catch (error) {
      console.error('Error sending message:', error);
      return rejectWithValue((error as Error).message);
    }
  }
);

export const createChannel = createAsyncThunk(
  'chat/createChannel',
  async ({ name, description, creatorId }: { name: string; description: string; creatorId: string }, { rejectWithValue }) => {
    try {
      console.log('Creating channel with enhanced function:', { name, description, creatorId });
      // Use our enhanced channel creation function instead
      return await createChannelChatEnhanced(name, description, creatorId);
    } catch (error) {
      console.error('Error creating channel:', error);
      return rejectWithValue((error as Error).message);
    }
  }
);

export const createDirectMessage = createAsyncThunk(
  'chat/createDirectMessage',
  async ({ 
    userId1, 
    userId2, 
    userName1, 
    userName2 
  }: { 
    userId1: string; 
    userId2: string; 
    userName1: string; 
    userName2: string 
  }, { rejectWithValue }) => {
    try {
      return await createDirectMessageChat(userId1, userId2, userName1, userName2);
    } catch (error) {
      console.error('Error creating direct message:', error);
      return rejectWithValue((error as Error).message);
    }
  }
);

// Function to unsubscribe from all chat subscriptions - call this on cleanup
export const unsubscribeAll = () => {
  unregisterSubscriptionsByPrefix('chats');
  unregisterSubscriptionsByPrefix('messages-');
};

const chatSlice = createSlice({
  name: 'chat',
  initialState,
  reducers: {
    setCurrentChat: (state, action: PayloadAction<string>) => {
      state.currentChatId = action.payload;
    },
    
    setChats: (state, action: PayloadAction<Chat[]>) => {
      state.activeChats = action.payload;
    },
    
    setMessages: (state, action: PayloadAction<{ chatId: string; messages: Message[] }>) => {
      const { chatId, messages } = action.payload;
      state.messages[chatId] = messages;
    },
    
    resetChatState: () => initialState,
  },
  extraReducers: (builder) => {
    // fetchUserChats
    builder.addCase(fetchUserChats.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(fetchUserChats.fulfilled, (state, action) => {
      state.activeChats = action.payload;
      state.loading = false;
    });
    builder.addCase(fetchUserChats.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
      console.error('fetchUserChats rejected with error:', action.payload);
    });
    
    // fetchChatMessages
    builder.addCase(fetchChatMessages.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(fetchChatMessages.fulfilled, (state, action) => {
      const { chatId, messages } = action.payload;
      state.messages[chatId] = messages;
      state.loading = false;
    });
    builder.addCase(fetchChatMessages.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // sendMessage
    builder.addCase(sendMessage.rejected, (state, action) => {
      state.error = action.payload as string;
    });
    
    // createChannel
    builder.addCase(createChannel.pending, (state) => {
      state.loading = true;
      state.error = null;
      console.log('createChannel.pending action dispatched');
    });
    builder.addCase(createChannel.fulfilled, (state, action) => {
      state.loading = false;
      console.log('createChannel.fulfilled with payload:', action.payload);
      // Manually add the new channel to activeChats for immediate feedback
      // It will be overwritten by the subscription, but this gives immediate UI update
      if (!state.activeChats.some(chat => chat.id === action.payload.id)) {
        state.activeChats = [...state.activeChats, action.payload];
      }
    });
    builder.addCase(createChannel.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
      console.error('createChannel.rejected with error:', action.payload);
    });
    
    // createDirectMessage
    builder.addCase(createDirectMessage.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(createDirectMessage.fulfilled, (state, action) => {
      state.loading = false;
      // Manually add the new DM to activeChats
      if (!state.activeChats.some(chat => chat.id === action.payload.id)) {
        state.activeChats = [...state.activeChats, action.payload];
      }
    });
    builder.addCase(createDirectMessage.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
  }
});

export const {
  setCurrentChat,
  setChats,
  setMessages,
  resetChatState
} = chatSlice.actions;

// For backwards compatibility with existing code
export const addChat = createChannel;
export const addMessage = sendMessage;

export default chatSlice.reducer;
</file>

<file path="src/store/slices/taskSlice.ts">
import { createSlice, PayloadAction, createAsyncThunk } from '@reduxjs/toolkit';
import { Task, TaskStatus } from '../../types/task';
import { TaskAttachment } from '../../types/attachment';
import {
  createTask as createTaskInFirestore,
  getAllTasks as getAllTasksFromFirestore,
  updateTaskInFirestore,
  updateTaskStatusInFirestore,
  deleteTaskFromFirestore,
  subscribeToTasks
} from '../../services/taskService';
import { 
  registerSubscription, 
  unregisterSubscriptionsByPrefix 
} from '../../utils/subscriptionManager';

interface TaskState {
  tasks: Task[];
  loading: boolean;
  error: string | null;
}

const initialState: TaskState = {
  tasks: [],
  loading: false,
  error: null,
};

// Async Thunks
export const fetchTasks = createAsyncThunk(
  'tasks/fetchTasks',
  async (_, { dispatch, rejectWithValue }) => {
    try {
      const tasks = await getAllTasksFromFirestore();
      
      // Setup real-time subscription using the subscription manager
      const unsubscribe = subscribeToTasks((updatedTasks) => {
        dispatch(setTasks(updatedTasks));
      });
      
      // Store the unsubscribe function in our manager, not in Redux state
      registerSubscription('tasks', unsubscribe);
      
      return tasks;
    } catch (error) {
      return rejectWithValue((error as Error).message);
    }
  }
);

export const createTaskThunk = createAsyncThunk(
  'tasks/createTask',
  async (task: Omit<Task, 'id'>, { rejectWithValue }) => {
    try {
      return await createTaskInFirestore(task);
    } catch (error) {
      return rejectWithValue((error as Error).message);
    }
  }
);

export const updateTaskThunk = createAsyncThunk(
  'tasks/updateTask',
  async (task: Task, { rejectWithValue }) => {
    try {
      await updateTaskInFirestore(task);
      return task;
    } catch (error) {
      return rejectWithValue((error as Error).message);
    }
  }
);

export const updateTaskStatusThunk = createAsyncThunk(
  'tasks/updateTaskStatus',
  async ({ taskId, status }: { taskId: string; status: TaskStatus }, { rejectWithValue }) => {
    try {
      await updateTaskStatusInFirestore(taskId, status);
      return { taskId, status };
    } catch (error) {
      return rejectWithValue((error as Error).message);
    }
  }
);

export const deleteTaskThunk = createAsyncThunk(
  'tasks/deleteTask',
  async (taskId: string, { rejectWithValue }) => {
    try {
      await deleteTaskFromFirestore(taskId);
      return taskId;
    } catch (error) {
      return rejectWithValue((error as Error).message);
    }
  }
);

// Function to unsubscribe from task updates - call this on cleanup
export const unsubscribeTasks = () => {
  unregisterSubscriptionsByPrefix('tasks');
};

const taskSlice = createSlice({
  name: 'tasks',
  initialState,
  reducers: {
    setTasks: (state, action: PayloadAction<Task[]>) => {
      state.tasks = action.payload;
    },

    // Local state updates for attachments - database updates handled in services
    addTaskAttachment: (
      state,
      action: PayloadAction<{ taskId: string; attachment: TaskAttachment }>
    ) => {
      const task = state.tasks.find(t => t.id === action.payload.taskId);
      if (task) {
        task.attachments = task.attachments || [];
        task.attachments.push(action.payload.attachment);
      }
    },

    removeTaskAttachment: (
      state,
      action: PayloadAction<{ taskId: string; attachmentId: string }>
    ) => {
      const task = state.tasks.find(t => t.id === action.payload.taskId);
      if (task && task.attachments) {
        task.attachments = task.attachments.filter(
          a => a.id !== action.payload.attachmentId
        );
      }
    },

    setLoading: (state, action: PayloadAction<boolean>) => {
      state.loading = action.payload;
    },

    setError: (state, action: PayloadAction<string | null>) => {
      state.error = action.payload;
      state.loading = false;
    },
  },
  extraReducers: (builder) => {
    // fetchTasks
    builder.addCase(fetchTasks.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(fetchTasks.fulfilled, (state, action) => {
      state.tasks = action.payload;
      state.loading = false;
    });
    builder.addCase(fetchTasks.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // createTaskThunk
    builder.addCase(createTaskThunk.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(createTaskThunk.fulfilled, (state) => {
      state.loading = false;
      // Task will be added by the subscription
    });
    builder.addCase(createTaskThunk.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // updateTaskThunk
    builder.addCase(updateTaskThunk.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(updateTaskThunk.fulfilled, (state) => {
      state.loading = false;
      // Task will be updated by the subscription
    });
    builder.addCase(updateTaskThunk.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
    
    // deleteTaskThunk
    builder.addCase(deleteTaskThunk.pending, (state) => {
      state.loading = true;
      state.error = null;
    });
    builder.addCase(deleteTaskThunk.fulfilled, (state) => {
      state.loading = false;
      // Task will be removed by the subscription
    });
    builder.addCase(deleteTaskThunk.rejected, (state, action) => {
      state.loading = false;
      state.error = action.payload as string;
    });
  }
});

export const { 
  setTasks,
  addTaskAttachment,
  removeTaskAttachment,
  setLoading,
  setError
} = taskSlice.actions;

// For backwards compatibility with existing code
export const addTask = createTaskThunk;
export const updateTask = updateTaskThunk;
export const updateTaskStatus = updateTaskStatusThunk;
export const deleteTask = deleteTaskThunk;

export default taskSlice.reducer;
</file>

<file path="src/types/__tests__/attachment.test.ts">
import { isValidFileType, isValidFileSize, FILE_CONSTRAINTS } from '../attachment';

describe('File Validation', () => {
  it('should validate allowed file types', () => {
    const validFile = new File([''], 'test.pdf', { type: 'application/pdf' });
    expect(isValidFileType(validFile)).toBe(true);
    
    const invalidFile = new File([''], 'test.exe', { type: 'application/x-msdownload' });
    expect(isValidFileType(invalidFile)).toBe(false);
  });

  it('should validate file size', () => {
    const smallFile = new File(['small'], 'small.txt', { type: 'text/plain' });
    Object.defineProperty(smallFile, 'size', { value: 1024 }); // 1KB
    expect(isValidFileSize(smallFile)).toBe(true);

    const largeFile = new File(['large'], 'large.txt', { type: 'text/plain' });
    Object.defineProperty(largeFile, 'size', { value: FILE_CONSTRAINTS.MAX_FILE_SIZE + 1 });
    expect(isValidFileSize(largeFile)).toBe(false);
  });
});
</file>

<file path="src/types/attachment.ts">
export interface TaskAttachment {
    id: string;
    taskId: string;
    fileName: string;
    fileType: string;
    fileSize: number;
    uploadedBy: string;
    uploadedAt: string;
    downloadUrl?: string;
    thumbnailUrl?: string;
  }
  
  export const ALLOWED_FILE_TYPES = [
    // Documents
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    'application/vnd.ms-powerpoint',
    'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    'text/plain',
    // Images
    'image/jpeg',
    'image/png',
    'image/gif',
    // Archives
    'application/zip',
    // Data
    'application/json',
    'text/csv',
    'text/markdown'
  ];
  
  export const FILE_CONSTRAINTS = {
    MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB in bytes
    MAX_TOTAL_SIZE: 50 * 1024 * 1024, // 50MB in bytes
  } as const;
  
  export const isValidFileType = (file: File): boolean => {
    return ALLOWED_FILE_TYPES.includes(file.type);
  };
  
  export const isValidFileSize = (file: File): boolean => {
    return file.size <= FILE_CONSTRAINTS.MAX_FILE_SIZE;
  };
</file>

<file path="src/types/auth.ts">
export interface UserRole {
    superAdmin?: boolean;
    workspaceAdmin?: boolean;
    teamLead?: boolean;
    member?: boolean;
    guest?: boolean;
  }
  
  export interface User {
    uid: string;
    email: string | null;
    displayName: string | null;
    photoURL?: string | null;
    roles: UserRole;
    createdAt: string;
    lastLogin: string;
  }
  
  export interface AuthState {
    user: User | null;
    loading: boolean;
    error: string | null;
  }
</file>

<file path="src/types/chat.ts">
export type MessageType = 'text' | 'file';
export type ChatType = 'channel' | 'direct';

export interface Message {
  id: string;
  content: string;
  type: MessageType;
  senderId: string;
  timestamp: string;
  fileUrl?: string;
  fileName?: string;
}

export interface Chat {
  id: string;
  type: ChatType;
  name: string; // Channel name or user name for direct messages
  description?: string;
  participants: string[]; // User IDs
  lastMessage?: Partial<Message>;
  unreadCount?: number;
  createdAt?: string;
  lastUpdated?: string;
  meta?: Record<string, any>; // For storing additional metadata like user details for DMs
}

export interface ChatState {
  activeChats: Chat[];
  messages: Record<string, Message[]>; // Keyed by chat ID
  currentChatId: string | null;
  loading: boolean;
  error: string | null;
}
</file>

<file path="src/types/index.ts">
export interface User {
    id: string;
    name: string;
    email: string;
    avatar?: string;
  }
  
  export interface NavigationItem {
    name: string;
    path: string;
    icon?: React.ComponentType;
  }
</file>

<file path="src/types/task.ts">
export type TaskPriority = 'low' | 'medium' | 'high';
export type TaskStatus = 'todo' | 'in_progress' | 'in_review' | 'done';
import { TaskAttachment } from './attachment';

export interface Task {
  id: string;
  title: string;
  description: string;
  status: TaskStatus;
  priority: TaskPriority;
  assignedTo?: string;
  createdBy: string;
  createdAt: string;
  dueDate?: string;
  tags: string[];
  attachments: TaskAttachment[];
}

export interface TaskColumn {
  id: TaskStatus;
  title: string;
  tasks: Task[];
}
</file>

<file path="src/utils/fileUtils.ts">
import { 
  DocumentIcon, 
  PhotoIcon, 
  ArchiveBoxIcon, 
  TableCellsIcon, 
  DocumentTextIcon, 
  PresentationChartBarIcon 
} from '@heroicons/react/24/outline';

type HeroIcon = typeof DocumentIcon;

export interface FileValidationResult {
  isValid: boolean;
  error?: string;
}

export interface FileTypeInfo {
  icon: HeroIcon;
  label: string;
  color: string;
}

export const ALLOWED_FILE_TYPES = [
  // Documents
  'application/pdf',
  'application/msword',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'application/vnd.ms-powerpoint',
  'application/vnd.openxmlformats-officedocument.presentationml.presentation',
  'text/plain',
  // Images
  'image/jpeg',
  'image/png',
  'image/gif',
  // Archives
  'application/zip',
  // Data
  'application/json',
  'text/csv',
  'text/markdown'
];

export const FILE_CONSTRAINTS = {
  MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB in bytes
  MAX_TOTAL_SIZE: 50 * 1024 * 1024, // 50MB in bytes
} as const;

export const isValidFileType = (file: File): boolean => {
  return ALLOWED_FILE_TYPES.includes(file.type);
};

export const isValidFileSize = (file: File): boolean => {
  return file.size <= FILE_CONSTRAINTS.MAX_FILE_SIZE;
};

export const validateFile = (file: File): FileValidationResult => {
  if (!isValidFileType(file)) {
    return {
      isValid: false,
      error: 'File type not supported'
    };
  }

  if (!isValidFileSize(file)) {
    return {
      isValid: false,
      error: `File size must be less than ${FILE_CONSTRAINTS.MAX_FILE_SIZE / (1024 * 1024)}MB`
    };
  }

  return { isValid: true };
};

export const formatFileSize = (bytes: number): string => {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return `${parseFloat((bytes / Math.pow(k, i)).toFixed(2))} ${sizes[i]}`;
};

export const getFileTypeInfo = (fileType: string): FileTypeInfo => {
  // Document types
  if (fileType === 'application/pdf') {
    return {
      icon: DocumentIcon,
      label: 'PDF',
      color: 'text-red-600',
    };
  }
  if (fileType.includes('spreadsheet') || fileType.includes('excel')) {
    return {
      icon: TableCellsIcon,
      label: 'Spreadsheet',
      color: 'text-green-600',
    };
  }
  if (fileType.includes('presentation') || fileType.includes('powerpoint')) {
    return {
      icon: PresentationChartBarIcon,
      label: 'Presentation',
      color: 'text-orange-600',
    };
  }
  if (fileType.includes('document') || fileType.includes('text')) {
    return {
      icon: DocumentTextIcon,
      label: 'Document',
      color: 'text-blue-600',
    };
  }
  // Image types
  if (fileType.startsWith('image/')) {
    return {
      icon: PhotoIcon,
      label: 'Image',
      color: 'text-purple-600',
    };
  }
  // Archive types
  if (fileType.includes('zip') || fileType.includes('archive')) {
    return {
      icon: ArchiveBoxIcon,
      label: 'Archive',
      color: 'text-gray-600',
    };
  }
  // Default
  return {
    icon: DocumentIcon,
    label: 'File',
    color: 'text-gray-600',
  };
};
</file>

<file path="src/utils/subscriptionManager.ts">
// A simple map to store subscription cleanup functions outside of Redux
const subscriptions: Record<string, () => void> = {};

// Register a subscription cleanup function
export const registerSubscription = (key: string, unsubscribeFn: () => void): void => {
  // Clean up any existing subscription with the same key
  unregisterSubscription(key);
  subscriptions[key] = unsubscribeFn;
};

// Unregister and execute a subscription cleanup function
export const unregisterSubscription = (key: string): void => {
  if (subscriptions[key]) {
    try {
      subscriptions[key]();
    } catch (error) {
      console.error(`Error unregistering subscription ${key}:`, error);
    }
    delete subscriptions[key];
  }
};

// Unregister all subscriptions for a specific prefix
export const unregisterSubscriptionsByPrefix = (prefix: string): void => {
  Object.keys(subscriptions).forEach(key => {
    if (key.startsWith(prefix)) {
      unregisterSubscription(key);
    }
  });
};

// Unregister all subscriptions
export const unregisterAllSubscriptions = (): void => {
  Object.keys(subscriptions).forEach(unregisterSubscription);
};
</file>

<file path="src/vite-env.d.ts">
/// <reference types="vite/client" />
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          500: '#0ea5e9',
          600: '#0284c7',
          700: '#0369a1',
        },
      }
    },
  },
  plugins: [],
}
</file>

<file path="tsconfig.app.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src", "jest.config.ts"]
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "types": ["jest", "node"]
  },
  "include": ["src"]
}
</file>

<file path="tsconfig.node.json">
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",
    "target": "ES2022",
    "lib": ["ES2023"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["vite.config.ts"]
}
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
</file>

</files>
